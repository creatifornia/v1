<!--ü¶ú Get Data ü¶ú-->

<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/2-get-creatifornia.js" defer></script>

<!-- ü¶ß GET Options  ü¶ß -->
<script type="text/javascript">
  document.addEventListener("creatifornia-ready", initOptions);
  document.addEventListener("update-options", initOptions);

  // Versi√≥n actual del sistema - ACTUALIZAR ESTO CON CADA CAMBIO
  const CURRENT_SYSTEM_VERSION = 'v1.0';

  function initOptions() {
    const authToken = localStorage.getItem("AuthToken");
    const existingOptions = localStorage.getItem("options");
    
    // Verificar si se fuerza refresco con par√°metro ?update
    const urlParams = new URLSearchParams(window.location.search);
    const forceRefresh = urlParams.has('update');
    
    if (forceRefresh && existingOptions) {
      console.log("üîÑ Refresh by URL");
      localStorage.removeItem("options");
    }
    
    // 1. Verificar si existen opciones con versi√≥n actual
    if (existingOptions && !forceRefresh) {
      try {
        const parsedOptions = JSON.parse(existingOptions);
        
        // Buscar la versi√≥n en las opciones almacenadas
        const storedVersion = parsedOptions.version;
        
        if (storedVersion === CURRENT_SYSTEM_VERSION) {
          document.dispatchEvent(new Event("cf-options-ready"));
          console.log("ü¶ß Options");
          return;
        }
        
        // Si la versi√≥n no coincide, eliminar para forzar nueva descarga
        localStorage.removeItem("options");
      } catch (e) {
        console.warn("Corrupted options, refreshing...");
        localStorage.removeItem("options");
      }
    }

    // 2. Solo continuar si no tenemos opciones actualizadas
    if (authToken) {
      xano.setAuthToken(authToken);
      
      // Funciones de transformaci√≥n (solo para categor√≠as)
      const transformOptions = (optionsArray) => {
        return optionsArray.reduce((acc, item) => {
          const key = Object.keys(item)[0];
          acc[key] = item[key];
          return acc;
        }, {});
      };
      
      const optimizeOptionsStructure = (optionsObj) => {
        return Object.fromEntries(
          Object.entries(optionsObj).map(([category, items]) => {
            // Solo aplicar transformaci√≥n si es un array (categor√≠a)
            if (!Array.isArray(items)) return [category, items];
            
            const optionsItem = items.find(item => item.options);
            const messageItem = items.find(item => item.message);
            
            return [
              category,
              {
                options: optionsItem?.options || [],
                message: messageItem?.message || 'Elige una opci√≥n'
              }
            ];
          })
        );
      };

      // Funci√≥n de reintentos para obtener par√°metros
      const getParamsWithRetry = (attempt = 0) => {
        const maxAttempts = 30;
        const retryDelay = 50;
        
        const offices = JSON.parse(localStorage.getItem("offices") || "{}");
        const lang = offices.country?.lang?.ISO_639;
        const countryCode = offices.country?.ISO_3166_1_alfa_2;
        
        if ((lang && countryCode) || attempt >= maxAttempts) {
          const finalLang = lang || 'es';
          const finalCountry = countryCode || 'MX';
          return { lang: finalLang, country: finalCountry };
        }
        
        return new Promise(resolve => {
          setTimeout(() => {
            resolve(getParamsWithRetry(attempt + 1));
          }, retryDelay);
        });
      };

      // 3. Proceso de descarga y almacenamiento
      (async () => {
        try {
          const { lang, country } = await getParamsWithRetry();
          const apiUrl = `/options?lang=${lang}&country=${country}`;
          
          const response = await xano.get(apiUrl);
          if (response?.body) {
            // Separar elementos de categor√≠a y no-categor√≠a
            const nonCategoryItems = {};
            const categoryItems = [];
            
            response.body.forEach(item => {
              const key = Object.keys(item)[0];
              // Elementos no-categor√≠a (como version)
              if (!Array.isArray(item[key])) {
                nonCategoryItems[key] = item[key];
              } 
              // Elementos categor√≠a
              else {
                categoryItems.push(item);
              }
            });
            
            // Aplicar transformaciones solo a categor√≠as
            const transformedCategories = transformOptions(categoryItems);
            const optimizedCategories = optimizeOptionsStructure(transformedCategories);
            
            // Combinar todo manteniendo la estructura original
            const finalOptions = {
              ...nonCategoryItems,
              ...optimizedCategories
            };
            
            // Guardar en localStorage SIN MODIFICACIONES ADICIONALES
            localStorage.setItem("options", JSON.stringify(finalOptions));
            console.log(`ü¶ß Options ${CURRENT_SYSTEM_VERSION}`);
            document.dispatchEvent(new Event("cf-options-ready"));
          }
        } catch (error) {
          console.error("‚ùå Options error:", error);
        }
      })();
    }
  }
</script>

<!-- üìò GET dynamic_text üìò -->
<script type="text/javascript">
  document.addEventListener("creatifornia-ready", dynamicText);
  document.addEventListener("update-dynamic_text", dynamicText);

  // Versi√≥n actual del sistema - ACTUALIZAR CON CAMBIOS
  const CURRENT_DYNAMIC_TEXT_VERSION = 'v1.0';

  function dynamicText() {
    const authToken = localStorage.getItem("AuthToken");
    const existingText = localStorage.getItem("dynamic_text");
    
    // Verificar par√°metro de actualizaci√≥n
    const urlParams = new URLSearchParams(window.location.search);
    const forceRefresh = urlParams.has('update');
    
    if (forceRefresh && existingText) {
      console.log("üîÑ Refresh by URL");
      localStorage.removeItem("dynamic_text");
    }
    
    // 1. Verificar si existe texto con versi√≥n actual
    if (existingText && !forceRefresh) {
      try {
        const parsedText = JSON.parse(existingText);
        
        // Buscar la versi√≥n en los textos almacenados
        const storedVersion = parsedText.version;
        
        if (storedVersion === CURRENT_DYNAMIC_TEXT_VERSION) {
          document.dispatchEvent(new Event("cf-dynamic_text-ready"));
          console.log("üìò Dynamic text");
          return;
        }
        
        // Si la versi√≥n no coincide, eliminar para forzar nueva descarga
        localStorage.removeItem("dynamic_text");
      } catch (e) {
        console.warn("Corrupted dynamic_text, refreshing...");
        localStorage.removeItem("dynamic_text");
      }
    }

    if (authToken) {
      xano.setAuthToken(authToken);
      
      // Funci√≥n para obtener par√°metros con reintentos
      const getParamsWithRetry = (attempt = 0) => {
        const maxAttempts = 30;
        const retryDelay = 50;
        
        const offices = JSON.parse(localStorage.getItem("offices") || "{}");
        const lang = offices.country?.lang?.ISO_639;
        const countryCode = offices.country?.ISO_3166_1_alfa_2;
        
        if ((lang && countryCode) || attempt >= maxAttempts) {
          const finalLang = lang || 'es';
          const finalCountry = countryCode || 'MX';
          return { lang: finalLang, country: finalCountry };
        }
        
        return new Promise(resolve => {
          setTimeout(() => {
            resolve(getParamsWithRetry(attempt + 1));
          }, retryDelay);
        });
      };

      (async () => {
        try {
          const { lang, country } = await getParamsWithRetry();
          const apiUrl = `/dynamic_text?lang=${lang}&country=${country}`;
          
          const response = await xano.get(apiUrl);
          if (response?.body) {
            // Procesamiento simplificado para estructura plana
            const finalText = {};
            
            // Aplanar todos los niveles de la respuesta
            response.body.flat(Infinity).forEach(item => {
              if (typeof item === 'object' && item !== null) {
                Object.entries(item).forEach(([key, value]) => {
                  // Solo asignar si es un valor primitivo
                  if (typeof value === 'string' || typeof value === 'number') {
                    finalText[key] = value;
                  }
                });
              }
            });
            
            localStorage.setItem("dynamic_text", JSON.stringify(finalText));
            console.log(`üìò Dynamic text ${CURRENT_DYNAMIC_TEXT_VERSION}`);
            document.dispatchEvent(new Event("cf-dynamic_text-ready"));
          }
        } catch (error) {
          console.error("‚ùå dynamic_text error:", error);
        }
      })();
    }
  }
</script>

<!-- üî† GET translate üî† -->
<script type="text/javascript">
  document.addEventListener("creatifornia-ready", dynamicText);
  document.addEventListener("update-translate", dynamicText);

  // Versi√≥n actual del sistema - ACTUALIZAR CON CAMBIOS
  const CURRENT_TRANSLATE_VERSION = 'v1.0';

  function dynamicText() {
    // Funci√≥n para obtener idioma con reintentos
    const getLanguageWithRetry = (attempt = 0) => {
      const maxAttempts = 30;
      const retryDelay = 50;
      
      const offices = JSON.parse(localStorage.getItem("offices") || "{}");
      const lang = offices.country?.lang?.ISO_639;
      
      if (lang || attempt >= maxAttempts) {
        return lang || 'es';
      }
      
      return new Promise(resolve => {
        setTimeout(() => {
          resolve(getLanguageWithRetry(attempt + 1));
        }, retryDelay);
      });
    };

    (async () => {
      // 1. Validaci√≥n inicial de idioma
      const lang = await getLanguageWithRetry();
      
      if (lang === 'es') {
        console.log("üî† Ready");
        document.dispatchEvent(new CustomEvent("translate-not-needed", {
          detail: { lang }
        }));
        return;
      }

      const authToken = localStorage.getItem("AuthToken");
      const existingText = localStorage.getItem("translate");
      
      // Verificar par√°metro de actualizaci√≥n
      const urlParams = new URLSearchParams(window.location.search);
      const forceRefresh = urlParams.has('update');
      
      if (forceRefresh && existingText) {
        console.log("üî† by URL");
        localStorage.removeItem("translate");
      }
      
      // 2. Verificar si existe texto con versi√≥n actual
      if (existingText && !forceRefresh) {
        try {
          const parsedText = JSON.parse(existingText);
          
          // Buscar la versi√≥n en los textos almacenados
          const storedVersion = parsedText.version;
          
          if (storedVersion === CURRENT_TRANSLATE_VERSION) {
            document.dispatchEvent(new Event("cf-translate-ready"));
            console.log("üî† Translate data");
            return;
          }
          
          // Si la versi√≥n no coincide, eliminar para forzar nueva descarga
          localStorage.removeItem("translate");
        } catch (e) {
          console.warn("Corrupted translate, refreshing...");
          localStorage.removeItem("translate");
        }
      }

      if (authToken) {
        xano.setAuthToken(authToken);
        
        // Funci√≥n para obtener pa√≠s con reintentos
        const getCountryWithRetry = (attempt = 0) => {
          const maxAttempts = 30;
          const retryDelay = 50;
          
          const offices = JSON.parse(localStorage.getItem("offices") || "{}");
          const countryCode = offices.country?.ISO_3166_1_alfa_2;
          
          if (countryCode || attempt >= maxAttempts) {
            return countryCode || 'MX';
          }
          
          return new Promise(resolve => {
            setTimeout(() => {
              resolve(getCountryWithRetry(attempt + 1));
            }, retryDelay);
          });
        };

        try {
          const country = await getCountryWithRetry();
          const apiUrl = `/translate?lang=${lang}&country=${country}`;
          
          const response = await xano.get(apiUrl);
          if (response?.body) {
            // Procesamiento simplificado para estructura plana
            const finalText = {};
            
            // Aplanar todos los niveles de la respuesta
            response.body.flat(Infinity).forEach(item => {
              if (typeof item === 'object' && item !== null) {
                Object.entries(item).forEach(([key, value]) => {
                  // Solo asignar si es un valor primitivo
                  if (typeof value === 'string' || typeof value === 'number') {
                    finalText[key] = value;
                  }
                });
              }
            });
            
            localStorage.setItem("translate", JSON.stringify(finalText));
            console.log(`üî† Translate data ${CURRENT_TRANSLATE_VERSION}`);
            document.dispatchEvent(new Event("translate-data-ready"));
          }
        } catch (error) {
          console.error("‚ùå translate error:", error);
        }
      }
    })();
  }
</script>


<!--üê≥ Fill Data üê≥ -->
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/4-fill-text.js" defer></script>
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/5-fill-inputs.js" defer></script>


<!-- falta cf-direct-input -->
<!-- üåç Translate üåç -->
<script>
document.addEventListener('cf-translate-ready', function() {
    try {
        // Obtener datos de traducci√≥n
        const translateData = JSON.parse(localStorage.getItem('translate')) || {};
        
        // Seleccionar todos los elementos con atributo cf
        const elements = document.querySelectorAll('[cf]');
        
        // Procesar cada elemento
        elements.forEach(element => {
            const componentName = element.getAttribute('cf');
            if (translateData[componentName]) {
                // Preservar HTML interno si es necesario
                if (element.innerHTML.trim() !== element.textContent.trim()) {
                    element.innerHTML = translateData[componentName];
                } else {
                    element.textContent = translateData[componentName];
                }
            }
        });
    } catch (error) {
        console.error('‚ùå Translation binding error:', error);
    }
    
    // Disparar evento de finalizaci√≥n
    document.dispatchEvent(new Event('translation-finished'));
    console.log("üåç Translation");
});

document.addEventListener('cf-translate-not-needed', function() {
    // Disparar inmediatamente evento de finalizaci√≥n
    document.dispatchEvent(new Event('translation-finished'));
});
</script>


<!------------------------üôâ Display üôâ ------------------------>
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/7-diplay.js" defer></script>


<!--üß± Builders üß±-->


<!-- üß± options-builder -->
<script>
document.addEventListener("cf-options-ready", buildOptionGroups);
document.addEventListener("cf-build-options-trigger", buildOptionGroups);

function buildOptionGroups() {
  const containers = document.querySelectorAll("[cf-options-build]");

  containers.forEach(container => {
    // Configuraci√≥n b√°sica
    const componentId = container.getAttribute("cf-options-build");
    const inputType = container.getAttribute("cf-options-type") || "checkbox";
    const key = container.getAttribute("cf-options-key");
    const path = `${container.getAttribute("cf-options-path")}.options`;
    const jsonPath = container.getAttribute("cf-options-path");
    const activeClass = container.getAttribute("cf-options-active") || "is-active-inputactive";
    const limit = container.getAttribute("cf-checkbox-limit");
    const cfRequired = container.getAttribute("cf-required");
    const requiredPath = `${key}.${container.getAttribute("cf-options-path")}.message`;
    const valueKey = container.getAttribute("cf-value-key") || "value";
    const tagKey = container.getAttribute("cf-tag-key") || "tag";
    const labelKey = container.getAttribute("cf-label-key") || "label";
    const submitPath = container.getAttribute("submit-json-path");  
    
    // Manejo de mensajes requeridos
    let cfMessage = "Select an option";
    if (requiredPath) {
      const [lsKey, ...pathParts] = requiredPath.split(".");
      if (lsKey && pathParts.length > 0) {
        try {
          const stored = JSON.parse(localStorage.getItem(lsKey));
          cfMessage = pathParts.reduce((acc, part) => acc?.[part], stored) || "Select one option";
        } catch {
          cfMessage = "Select one option";
        }
      }
    }

    // Configuraci√≥n de relaciones parent-child
    const isParent = container.hasAttribute("cf-options-parent");
    const isChild = container.hasAttribute("cf-options-child");
    const childGroupName = container.getAttribute("cf-options-child") || "";
    const targetValue = container.getAttribute("cf-options-target") || "";

    // Campos de datos (sin 'class')
    const fields = {
      value: valueKey, 
      label: labelKey,
      id: "id",
      tag: tagKey
      
    };

    // Obtener plantilla
    const template = document.querySelector(`[data-options-component="${componentId}"]`);
    if (!template) {
      console.error(`Template no encontrado: data-options-component="${componentId}"`);
      return;
    }

    const baseGroup = template.querySelector("[data-options-group]");
    const fieldTemplate = template.querySelector("[data-options-field]");

    if (!baseGroup || !fieldTemplate) {
      console.error("La plantilla necesita [data-options-group] y [data-options-field]");
      return;
    }

    // Obtener datos
    let data;
    try {
      data = JSON.parse(localStorage.getItem(key));
    } catch {
      console.warn(`Datos inv√°lidos en localStorage["${key}"]`);
      return;
    }

    const list = path.split('.').reduce((acc, prop) => acc?.[prop], data);
    if (!Array.isArray(list) || list.length === 0) {
      console.warn(`Lista no encontrada en ${key} ‚Üí ${path}`);
      return;
    }

    // Clonar grupo base
    const groupClone = baseGroup.cloneNode(false);
    groupClone.setAttribute("data-options-group", "");
    groupClone.setAttribute("group-id", jsonPath);

    // Configurar target si existe
    if (targetValue) {
      container.setAttribute("cf-options-target", targetValue);
    }

    // Crear input hidden con soporte para ID
    const hiddenInput = document.createElement("input");
    hiddenInput.type = "hidden";
    hiddenInput.setAttribute("cf-json-path", submitPath || jsonPath);
    hiddenInput.setAttribute("name", path);
    hiddenInput.setAttribute("data-required-message", cfMessage);
    
    if (inputType === "checkbox" && limit) {
      hiddenInput.setAttribute("cf-checkbox-limit", limit);
    }

    if (isChild) {
      hiddenInput.setAttribute("cf-options-display-input", childGroupName);
    }

    if (isParent && cfRequired === "true") {
      hiddenInput.setAttribute("data-required", "");
    }

    hiddenInput.value = inputType === "checkbox" ? "[]" : "";
    groupClone.appendChild(hiddenInput);

    // Procesar cada opci√≥n
    list.forEach(item => {
      const field = fieldTemplate.cloneNode(true);
      field.classList.remove(activeClass);

      const input = field.querySelector("[data-options-button]");
      const label = field.querySelector("[data-options-label]");
      const tagElement = field.querySelector("[label-tag]");

      if (!input || !label) return;

      input.type = inputType;
      input.setAttribute("cf-options-value", item[fields.value]);
      input.setAttribute("cf-options-label", item[fields.label]);
      
      // Asegurar que el ID se env√≠a correctamente
      if (item[fields.id]) {
        input.setAttribute("cf-options-id", item[fields.id]);
      }
      
      input.setAttribute("cf-options-path", submitPath || jsonPath);
      input.setAttribute("cf-options-active", activeClass);
      input.setAttribute("name", inputType === "radio" ? path : "");

      if (isParent) {
        input.setAttribute("cf-options-parent", container.getAttribute("cf-options-parent"));
      }

      label.textContent = item[fields.label];
      
      // Manejar tag si existe
      if (tagElement) {
        const tagValue = item[fields.tag]?.trim() || "";
        tagElement.textContent = tagValue;
        tagElement.style.display = tagValue ? "block" : "none";
      }

      groupClone.appendChild(field);
    });

    container.appendChild(groupClone);
  });

  // Ocultar plantillas originales
  document.querySelectorAll("[data-options-component]").forEach(el => {
    el.style.display = "none";
  });
  
  document.dispatchEvent(new Event("options-builder-ready"));
}
</script>

<!-- üß± keywords-builder -->
<script>
document.addEventListener("cf-options-ready", buildKeywords);
document.addEventListener("cf-build-keywords-trigger", buildKeywords);

function buildKeywords() {
    const containers = document.querySelectorAll("[cf-keywords-build]");

    containers.forEach(container => {
        const componentId = container.getAttribute("cf-keywords-build");
        const formPath = container.getAttribute("form-path");
        const keywordsLimit = container.getAttribute("keywords-limit");
        const maxLength = container.getAttribute("maxlength") || "256";
        const cfRequired = container.getAttribute("cf-required");
        const customMessage = DynamicText.get('keywords')
        const child = container.getAttribute("cf-child");
        const target = container.getAttribute("cf-target");
        const template = document.getElementById(componentId);
        if (!template) {
            console.error(`‚ùå No se encontr√≥ template con id="${componentId}"`);
            return;
        }

        // CORRECCI√ìN 1: Asegurar que el contenedor principal sea visible
        container.style.display = "block";
        container.style.opacity = "1";
        container.style.visibility = "visible";

        // Clonar el template conservando todas las clases y estructura
        const clone = template.cloneNode(true);
        clone.removeAttribute("id");
        
        // CORRECCI√ìN 2: Eliminar display:none del clon
        clone.style.display = "block";
        container.appendChild(clone);

        // Obtener elementos del clon
        const wordsGroup = clone.querySelector("[words-group]");
        const wordButtonTemplate = wordsGroup.querySelector("[word-button]").cloneNode(true);
        const textFieldContainer = clone.querySelector("[text-field-container]");
        const input = textFieldContainer.querySelector("[keywords-input]");
        const addButton = textFieldContainer.querySelector("[add-button]");

        // Eliminar el ejemplo del template clonado
        wordsGroup.innerHTML = "";

        // Configurar input
        input.setAttribute("maxlength", maxLength);

        // Crear input hidden para almacenar las palabras
        const hiddenInput = document.createElement("input");
        hiddenInput.type = "hidden";
        hiddenInput.setAttribute("cf-json-path", formPath);
        hiddenInput.setAttribute("name", formPath);
        hiddenInput.setAttribute("data-required-message", customMessage);
        hiddenInput.setAttribute("cf-options-child", child);
        hiddenInput.setAttribute("cf-options-target", target);
        hiddenInput.value = "[]";
        
        if (cfRequired === "true") {
            hiddenInput.setAttribute("data-required", "");  
        }
        container.insertBefore(hiddenInput, clone);

        // Estado inicial - array vac√≠o
        let keywords = [];

        // Funci√≥n para actualizar el input hidden y la vista
        const updateKeywords = () => {
            hiddenInput.value = JSON.stringify(keywords);
            
            // Actualizar vista
            wordsGroup.innerHTML = "";
            keywords.forEach((keyword, index) => {
                const keywordElement = wordButtonTemplate.cloneNode(true);
                keywordElement.querySelector("[generated-keyword]").textContent = keyword;
                
                keywordElement.addEventListener("click", (e) => {
                    e.preventDefault();
                    keywords = keywords.filter((_, i) => i !== index);
                    updateKeywords();
                });
                
                wordsGroup.appendChild(keywordElement);
            });
        };

        // Funci√≥n para agregar nueva palabra
        const addKeyword = () => {
            const newKeyword = input.value.trim();
            
            if (!newKeyword) return;
            
            if (keywordsLimit && keywords.length >= parseInt(keywordsLimit)) {
                showErrorModal(`M√°ximo ${keywordsLimit} palabras permitidas`);
                return;
            }
            
            if (keywords.includes(newKeyword)) {
                showErrorModal("Esta palabra ya fue agregada");
                return;
            }
            
            keywords.push(newKeyword);
            input.value = "";
            updateKeywords();
        };

        // Event listeners
        addButton.addEventListener("click", (e) => {
            e.preventDefault();
            addKeyword();
        });
        
        input.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                addKeyword();
            }
        });

        // Ocultar template original
        template.style.display = "none";
        
        // Inicializar con vista vac√≠a
        updateKeywords();
    });

    document.dispatchEvent(new Event("keywords-builder-ready"));
}
</script>

<!-- üí∞ currency-builder -->
<script>
document.addEventListener("cf-options-ready", function() {
  const containers = document.querySelectorAll("[cf-currency-build]");
  
  containers.forEach(container => {
    const visibleInput = container.querySelector("input[type='text']");
    if (!visibleInput) return;

    // Obtener configuraci√≥n
    const data = JSON.parse(localStorage.getItem("offices") || '{}');
    const currencyConfig = data?.country?.currency || {};
    const currency = currencyConfig?.ISO_4217 || 'MXN';
    const symbol = currencyConfig?.symbol || '$';
    const minCurrency = parseFloat(container.getAttribute("cf-min-currency")) || 0;
    const maxCurrency = parseFloat(container.getAttribute("cf-max-currency")) || Number.MAX_SAFE_INTEGER;
    const jsonPath = container.getAttribute("cf-currency-path");
    const cfRequired = container.getAttribute("cf-required") === 'true';
    
    // Construcci√≥n de mensajes
    const requiredMessage = currencyConfig?.required_message;
    const minimumMessage = currencyConfig?.minimum_message ? 
      `${currencyConfig.minimum_message} ${symbol}${(minCurrency/100).toFixed(2)}` : 
      `El monto m√≠nimo es ${symbol}${(minCurrency/100).toFixed(2)}`;
    
    const maxMessage = currencyConfig?.max_message ? 
      `${currencyConfig.max_message} ${symbol}${(maxCurrency/100).toFixed(2)}` : 
      `El monto m√°ximo es ${symbol}${(maxCurrency/100).toFixed(2)}`;

    // Crear hidden input con atributos de validaci√≥n
    const hiddenInput = document.createElement('input');
    hiddenInput.type = 'hidden';
    hiddenInput.name = jsonPath;
    hiddenInput.setAttribute('cf-json-path', jsonPath);
    hiddenInput.setAttribute('data-min-amount', minCurrency);
    hiddenInput.setAttribute('data-max-amount', maxCurrency);
    hiddenInput.setAttribute('data-currency-symbol', symbol);
    hiddenInput.setAttribute('data-currency-code', currency);
    hiddenInput.setAttribute('data-min-message', minimumMessage);
    hiddenInput.setAttribute('data-max-message', maxMessage);
    
    if (cfRequired && requiredMessage) {
      hiddenInput.setAttribute('data-required', '');
      hiddenInput.setAttribute('data-required-message', requiredMessage);
    }
    
    container.insertBefore(hiddenInput, visibleInput.nextSibling);

    let currentValue = 0;
    let lastValidValue = '';

    // Funci√≥n para validar caracteres - CORRECCI√ìN APLICADA
    const validateInput = (value) => {
      const validChars = /^[\d.,]*$/;
      const decimalSeparators = value.match(/[.,]/g) || [];
      
      // CORRECCI√ìN: Sintaxis mejorada
      if (decimalSeparators.length > 1) return false;
      
      if (value.includes('.') || value.includes(',')) {
        const parts = value.split(/[.,]/);
        if (parts[1] && parts[1].length > 2) return false;
      }
      
      return validChars.test(value);
    };

// Funci√≥n para formatear valor
const formatDisplayValue = (value) => {
  return `${symbol}${value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ",")}`;
};

// Funci√≥n para formatear valor completo (con s√≠mbolo y c√≥digo moneda)
const formatDisplayValueFull = (value) => {
  return `${symbol}${value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ",")} ${currency}`;
};

// Actualizar valores internos
const updateCurrencyValue = (value) => {
  const numericValue = parseFloat(value.replace(/,/g, '.')) || 0;
  currentValue = numericValue;
  
  hiddenInput.value = JSON.stringify({
    unit_amount: Math.round(numericValue * 100), // En centavos (para Stripe)
    display_value: formatDisplayValue(numericValue), // "$78.60"
    display_value_full: formatDisplayValueFull(numericValue), // "$78.60 MXN"
    currency: currency,
    symbol: symbol,
    raw_value: numericValue // 78.6
  });
};

    // Evento input
    visibleInput.addEventListener('input', (e) => {
      const value = e.target.value;
      
      if (!validateInput(value)) {
        visibleInput.classList.add('invalid');
        setTimeout(() => visibleInput.classList.remove('invalid'), 500);
        e.target.value = lastValidValue;
        return;
      }
      
      lastValidValue = value;
      updateCurrencyValue(value);
    });

    // Evento blur
    visibleInput.addEventListener('blur', () => {
      if (currentValue < (minCurrency/100)) {
        visibleInput.value = formatDisplayValue(minCurrency/100);
        updateCurrencyValue((minCurrency/100).toString());
        showErrorModal(minimumMessage)
      } else if (currentValue > (maxCurrency/100)) {
        visibleInput.value = formatDisplayValue(maxCurrency/100);
        updateCurrencyValue((maxCurrency/100).toString());
        showErrorModal(maxMessage)
      } else {
        visibleInput.value = formatDisplayValue(currentValue);
      }
    });
  });
  
  document.dispatchEvent(new Event('currency-builder-ready'));
});
</script>

<!-- üî§ url-friendly-builder (actualizado) -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  const containers = document.querySelectorAll('[url-friendly]');
  
  containers.forEach(container => {
    const componentId = container.getAttribute('url-friendly');
    const jsonPath = container.getAttribute('json-path');
    const template = document.getElementById(componentId);
    const messagePath = container.getAttribute('message-path');
    const buildMessage = DynamicText.getWithDefault(messagePath, 'Campo requerido');
    
    if (!template) {
      console.error(`‚ùå No se encontr√≥ template con id="${componentId}"`);
      return;
    }
    
    // Clonar el template conservando estructura y clases
    const clone = template.cloneNode(true);
    clone.removeAttribute('id');
    container.appendChild(clone);
    
    // Obtener elementos del clon
    const previewText = clone.querySelector('[update-this-with-type-username]');
    const previewUrl = clone.querySelector('[update-this-with-type-url]');
    const input = clone.querySelector('[text-input-element]');
    
    // Crear input hidden para los datos
    const hiddenInput = document.createElement('input');
    hiddenInput.type = 'hidden';
    hiddenInput.setAttribute('cf-json-path', jsonPath);    
    hiddenInput.setAttribute('data-required-message', buildMessage);
    hiddenInput.setAttribute('data-required', '');
    hiddenInput.value = JSON.stringify({
      club_name: '',
      url_friendly: ''
    });
    container.insertBefore(hiddenInput, clone);
    
    // Funci√≥n para validar caracteres (ahora permite espacios)
    function isValidChar(char) {
      return /^[\p{L}\p{N}\s_-]$/u.test(char);
    }
    
    // Funci√≥n para normalizar texto a URL friendly
    function toUrlFriendly(text) {
      return text.trim()
        .toLowerCase()
        .replace(/\s+/g, '-')       // Espacios a guiones
        .replace(/_/g, '-')         // Guiones bajos a guiones
        .normalize('NFD')           // Separar caracteres y acentos
        .replace(/[\u0300-\u036f]/g, '')  // Eliminar diacr√≠ticos
        .replace(/[^\w-]/g, '');    // Eliminar caracteres no alfanum√©ricos
    }
    
    // Funci√≥n para mostrar error (shake)
    function showInputError() {
      input.classList.add('invalid');
      setTimeout(() => input.classList.remove('invalid'), 500);
    }
    
    // Actualizar vista y datos
    function updateUrlPreview(value) {
      // Limitar a 20 caracteres (ahora se aplica directamente al input)
      const normalized = value.trim();
      
      // Aplicar formato especial para el preview de nombre de usuario
      const usernameDisplay = normalized
        .replace(/-/g, '_')  // Reemplazar guiones por guiones bajos
        .replace(/\s+/g, ' '); // Mantener espacios como espacios
      
      const friendly = toUrlFriendly(value);
      
      // Actualizar ambos previews
      if (previewText) {
        previewText.textContent = usernameDisplay || DynamicText.getWithDefault(messagePath, '');
      }
      
      if (previewUrl) {
        previewUrl.textContent = friendly || DynamicText.getWithDefault(messagePath, '');
      }
      
      // Actualizar hidden input
      hiddenInput.value = JSON.stringify({
        club_name: normalized,
        url_friendly: friendly
      });
    }
    
    // Event listeners
    if (input) {
      let lastValidValue = '';
      const MAX_LENGTH = 20;
      
      input.addEventListener('input', (e) => {
        const value = e.target.value;
        
        // Verificar l√≠mite de caracteres
        if (value.length > MAX_LENGTH) {
          input.value = lastValidValue;
          showInputError();
          return;
        }
        
        // Verificar cada car√°cter nuevo
        const newChar = value.length > lastValidValue.length ? 
                        value.charAt(value.length - 1) : null;
        
        // Si se a√±ade un car√°cter inv√°lido
        if (newChar && !isValidChar(newChar)) {
          // Revertir al √∫ltimo valor v√°lido
          input.value = lastValidValue;
          showInputError();
          return;
        }
        
        // Actualizar el √∫ltimo valor v√°lido
        lastValidValue = value;
        updateUrlPreview(value);
      });
      
      // Manejar eventos de teclado para prevenir caracteres inv√°lidos
      input.addEventListener('keypress', (e) => {
        const char = String.fromCharCode(e.keyCode || e.which);
        
        if (!isValidChar(char)) {
          e.preventDefault();
          showInputError();
        }
      });
      
      // Manejar pegado de texto
      input.addEventListener('paste', (e) => {
        e.preventDefault();
        const clipboardData = e.clipboardData || window.clipboardData;
        const pastedText = clipboardData.getData('text');
        let validText = lastValidValue;
        
        // Filtrar solo caracteres v√°lidos
        for (const char of pastedText) {
          if (validText.length >= MAX_LENGTH) break;
          if (isValidChar(char)) {
            validText += char;
          }
        }
        
        // Actualizar el valor con solo caracteres v√°lidos
        input.value = validText;
        lastValidValue = validText;
        updateUrlPreview(validText);
        
        // Mostrar error si se trunc√≥ texto
        if (validText.length < (lastValidValue.length + pastedText.length)) {
          showInputError();
        }
      });
      
      // Inicializar
      updateUrlPreview(input.value);
      lastValidValue = input.value;
    }
    
    // Ocultar template original
    template.style.display = 'none';
  });

  document.dispatchEvent(new Event('url-builder-ready'));
});
</script>

<!--üêá Handlers üêá-->

<!-- üéØ cf-options-handler actualizado para Xano (env√≠a ID y valores simplificados) -->
<script>
document.addEventListener("options-builder-ready", () => {
  document.querySelectorAll("[cf-options-value]").forEach(input => {
    input.addEventListener("change", () => {
      const value = input.getAttribute("cf-options-value");
      const label = input.getAttribute("cf-options-label");
      const id = input.getAttribute("cf-options-id"); // Nuevo: capturar ID
      const path = input.getAttribute("cf-options-path");
      const type = input.type;
      const field = input.closest("[data-options-field]");
      const group = input.closest("[data-options-group]");
      const activeClass = input.getAttribute("cf-options-active");

      if (!path || !group) return;

      const hidden = group.querySelector(`input[type="hidden"][cf-json-path="${path}"]`);
      if (!hidden) {
        console.error(`No input hidden con cf-json-path="${path}"`, group);
        return;
      }

      // Manejo diferenciado inicial
      let currentValue;
      if (type === "checkbox") {
        try { currentValue = JSON.parse(hidden.value || "[]"); }
        catch { currentValue = []; console.warn("Error parseando JSON:", hidden.value); }
      } else if (type === "radio") {
        try { currentValue = hidden.value ? JSON.parse(hidden.value) : null; }
        catch { currentValue = null; }
      }

      // Objeto completo con value, label e id
      const entry = { 
        value, 
        label, 
        ...(id && { id }) // Solo incluir ID si existe
      };

      if (type === "checkbox") {
        const isActive = input.checked;
        const exists = currentValue.some(item => item.value === value);

        // Validaci√≥n de l√≠mite (s√≥lo para checkboxes)
        if (isActive && !exists) {
          const limit = hidden.hasAttribute("cf-checkbox-limit") 
                      ? parseInt(hidden.getAttribute("cf-checkbox-limit"))
                      : null;
          
          if (limit !== null && currentValue.length >= limit) {
            showErrorModal(`Selecciona m√°ximo ${limit} opciones.`);
            input.checked = false;
            return;
          }
        }

        field?.classList.toggle(activeClass, isActive);
        
        if (isActive && !exists) {
          currentValue.push(entry);
        } else if (!isActive && exists) {
          currentValue = currentValue.filter(item => item.value !== value);
        }

      } else if (type === "radio") {
        // Radio ahora maneja objeto simple (no array)
        group.querySelectorAll(`[type="radio"][cf-options-path="${path}"]`)
             .forEach(r => r.closest("[data-options-field]")?.classList.remove(activeClass));
        field?.classList.add(activeClass);
        currentValue = entry; // Asignaci√≥n directa del objeto (no array)
      }

      // Serializaci√≥n para Xano (conserva estructura simple)
      hidden.value = type === "checkbox" ? JSON.stringify(currentValue) 
                   : currentValue ? JSON.stringify(currentValue) : "";

      // Evento personalizado actualizado con ID
      document.dispatchEvent(new CustomEvent(`valid-change-${type}`, {
        detail: {
          input,
          value,
          label,
          id, // Nuevo: incluir ID en el evento
          path,
          type,
          isChecked: input.checked
        }
      }));
    });
  });
});

// Funci√≥n auxiliar para mostrar errores (si no existe)
function showErrorModal(message) {
  if (typeof showToast === 'function') {
    showToast(message, 'error');
  } else if (typeof alert === 'function') {
    alert(message);
  } else {
    console.error(message);
  }
}
</script>

<!-- üß© cf-options-display (checkbox) - Versi√≥n optimizada con soporte "any" -->
<script>
  document.addEventListener("valid-change-checkbox", (e) => {
    const { input, value, path, isChecked } = e.detail;
    const parent = input.closest('[cf-options-parent]')?.getAttribute("cf-options-parent");


    
    if (!value || !parent) return;

    // 1. Manejo de divs de display (compatible con "any")
    document.querySelectorAll(`
      [cf-options-display-div="${parent}"][cf-options-match="${value}"],
      [cf-options-display-div="${parent}"][cf-options-match="any"]
    `).forEach(div => {
      const isAny = div.getAttribute("cf-options-match") === "any";
      
      // Mostrar si: es "any" O est√° checked (para match espec√≠fico)
      div.style.display = (isAny || isChecked) ? "block" : "none";
      console.log(`üîÑ ${value}: ${isChecked ? 'üôâ' : 'üôà'}`);
    });

// 2. Manejo de grupos hijos y required (con soporte "any")
document.querySelectorAll(`
  [cf-options-child="${parent}"][cf-options-target="${value}"],
  [cf-options-child="${parent}"][cf-options-target="any"]
`).forEach(child => {
  const hiddenInputs = child.querySelectorAll('input[cf-json-path]');
  const isAny = child.getAttribute("cf-options-target") === "any";

  hiddenInputs.forEach(hiddenInput => {
    if (isAny || isChecked) {
      hiddenInput.setAttribute("data-required", "");
    } else {
      hiddenInput.removeAttribute("data-required");
    }
  });
});


// 2. Manejo de directo de inputs (required)
document.querySelectorAll(`
  input[cf-options-child="${parent}"][cf-options-target="${value}"],
  input[cf-options-child="${parent}"][cf-options-target="any"]
`).forEach(input => {
  const isAny = input.getAttribute("cf-options-target") === "any";

  if (isAny || isChecked) {
    input.setAttribute("data-required", "");
  } else {
    input.removeAttribute("data-required");
  }
});




    // 3. Actualizaci√≥n de formulario (sin cambios)
    if (input) {
      const parentForm = input.closest('[cf-form-submit]');
      const formIdentifier = parentForm?.getAttribute('cf-form-submit');

      if (formIdentifier) {
        document.dispatchEvent(new CustomEvent('cf-update-form', {
          detail: { formIdentifier }
        }));
      }
    }
  });
</script>


<!-- üß© cf-options-display (radio) -->
<script>
  document.addEventListener("valid-change-radio", (e) => {
    const { input, value, isChecked } = e.detail;
    const parent = input.closest('[cf-options-parent]')?.getAttribute("cf-options-parent");
    if (!value || !parent) return;

    // 1. Ocultar TODOS los divs primero (excepto los "any")
    document.querySelectorAll(`[cf-options-display-div="${parent}"]`).forEach(div => {
      if (div.getAttribute("cf-options-match") !== "any") {
        div.style.display = "none";
      }
    });

    // 2. Mostrar solo los relevantes (match o any)
    document.querySelectorAll(`
      [cf-options-display-div="${parent}"][cf-options-match="${value}"],
      [cf-options-display-div="${parent}"][cf-options-match="any"]
    `).forEach(div => {
      div.style.display = "block";
    });

// 3. L√≥gica de required actualizada (con soporte "any")
// Limpiar TODOS los data-required primero
document.querySelectorAll(`[cf-options-child="${parent}"] input[cf-json-path]`).forEach(input => {
  input.removeAttribute("data-required");
});

// Agregar required a los grupos relevantes
if (isChecked) {
  document.querySelectorAll(`
    [cf-options-child="${parent}"][cf-options-target="${value}"],
    [cf-options-child="${parent}"][cf-options-target="any"]
  `).forEach(child => {
    child.querySelectorAll('input[cf-json-path]').forEach(input => {
      input.setAttribute("data-required", "");
    });
  });
}

// 2. Manejo de directo de inputs (required)
document.querySelectorAll(`
  input[cf-options-child="${parent}"][cf-options-target="${value}"],
  input[cf-options-child="${parent}"][cf-options-target="any"]
`).forEach(input => {
  const isAny = input.getAttribute("cf-options-target") === "any";

  if (isAny || isChecked) {
    input.setAttribute("data-required", "");
  } else {
    input.removeAttribute("data-required");
  }
});







    // 4. Actualizar formulario
    const formIdentifier = input.closest('[cf-form-submit]')?.getAttribute('cf-form-submit');
    formIdentifier && document.dispatchEvent(new CustomEvent('cf-update-form', {
      detail: { formIdentifier }
    }));
  });
</script>


<!-- ü¶ú cf-events-manager  (#1 cf-inputs-ready)ü¶ú -->
<script>
  (function() {
    const REQUIRED_EVENTS = [
      "cf-fill-inputs-ready",
      "options-builder-ready",
      "keywords-builder-ready",
      "currency-builder-ready",
                     ];

    let receivedEvents = new Set();

    function checkAllReady() {
      if (REQUIRED_EVENTS.every(event => receivedEvents.has(event))) {
        console.log("‚úÖ Events ready: (inputs)");
        document.dispatchEvent(new Event("cf-inputs-ready"));
        resetCoordinator(); // ‚¨ÖÔ∏è Reinicio autom√°tico justo despu√©s
      }
    }

    function resetCoordinator() {
      receivedEvents.clear();
    }

    // Escucha todos los eventos requeridos
    REQUIRED_EVENTS.forEach(eventName => {
      document.addEventListener(eventName, () => {
        if (!receivedEvents.has(eventName)) {
          console.log(`üì• Event (inputs): ${eventName}`);
          receivedEvents.add(eventName);
          checkAllReady();
        }
      });
    });
  })();
</script>


<!-- ‚ö° form submit ‚ö° -->
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/form-submit.js" defer></script>


<!-- ü¶ú cf-events-manager  (cf-loader-off)ü¶ú -->
<script>
  (function() {
    const REQUIRED_EVENTS = [
      "cf-display-ready",
      "submit-ready",
      "cf-text-ready",
      "translation-finished",
      "url-builder-ready",
                ];

    let receivedEvents = new Set();

    function checkAllReady() {
      if (REQUIRED_EVENTS.every(event => receivedEvents.has(event))) {
        console.log("‚úÖ Events ready (loader)");
        document.dispatchEvent(new Event("cf-loader-off"));
        resetCoordinator(); // ‚¨ÖÔ∏è Reinicio autom√°tico justo despu√©s
      }
    }

    

    function resetCoordinator() {
      receivedEvents.clear();
    }

    // Escucha todos los eventos requeridos
    REQUIRED_EVENTS.forEach(eventName => {
      document.addEventListener(eventName, () => {
        if (!receivedEvents.has(eventName)) {
          console.log(`üì• Event (loader): ${eventName}`);
          receivedEvents.add(eventName);
          checkAllReady();
        }
      });
    });
  })();
</script>

     
      

<!--üê¨ Tools üê¨-->
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/6-reset-tabs.js" defer></script>
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/1-loader.js" defer></script>
<!--  üßØ Modal de error -->
  
  <script>
  function showErrorModal(message) {
    const modal = document.getElementById('error-modal');
    const messageElement = document.getElementById('error-message');
    if (modal && messageElement) {
      messageElement.innerText = message;
      modal.style.display = 'flex';
    } else {
      console.error("‚ùå Elementos del modal no encontrados");
    }
  }

  function closeErrorModal() {
    const modal = document.getElementById('error-modal');
    if (modal) modal.style.display = 'none';
  }
</script>

<!--------------------- üê¨ Tools üê¨  --------------------->
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/fill-specific-inputs.js" defer></script>
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/mirror-click.js" defer></script>
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/reload-form.js" defer></script>
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/reload-form-part-2.js" defer></script>
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/refresh.js" defer></script>   
<script src="https://cdn.jsdelivr.net/gh/creatifornia/v1@main/update/ms-emojis.js" defer></script>


<!--üê¨ .get('') üê¨ -->

<!-- üê¨ DynamicText.get('') üê¨ -->
<script>
window.DynamicText = {
  get: function(key) {
    try {
      const data = JSON.parse(localStorage.getItem('dynamic_text') || '{}');
      return data[key];
    } catch (error) {
      console.error('Error al leer dynamic_text:', error);
      return undefined;
    }
  },
  
  getWithDefault: function(key, defaultValue = '') {
    return this.get(key) || defaultValue;
  }
};
</script>


<!-- üê¨ OfficesText.get('') üê¨ -->
<script>
window.Offices = {
  get: function(key) {
    try {
      const data = JSON.parse(localStorage.getItem('offices') || '{}');
      return data[key];
    } catch (error) {
      console.error('Error al leer offices:', error);
      return undefined;
    }
  },
  
  getWithDefault: function(key, defaultValue = '') {
    return this.get(key) || defaultValue;
  }
};
</script>


 <!--------------------- üêû Uploadcare üêû  --------------------->

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@uploadcare/file-uploader@v1/web/uc-file-uploader-regular.min.css" />

<script type="module">
  import * as UC from 'https://cdn.jsdelivr.net/npm/@uploadcare/file-uploader@v1/web/file-uploader.min.js';
  import es from 'https://cdn.jsdelivr.net/npm/@uploadcare/file-uploader@v1/locales/file-uploader/es.js';

  // Define el locale espa√±ol
  UC.defineLocale('es', es);

  // Define los componentes despu√©s de definir el locale
  UC.defineComponents(UC);
</script>


<!--üê∏ HTML üê∏-->


<!-- üê∏ MODAL response error  üê∏ -->

<div id="error-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000; justify-content:center; align-items:center;">
    <div style="background:#292626; padding:2rem; border-radius:1rem; max-width:400px; width:90%; text-align:center; color:#e7cfb1; font-family:sans-serif; box-shadow:0 10px 30px rgba(0,0,0,0.3);">
      <h2 style="margin-bottom:1rem; font-size:18px;">üîî</h2> <!-- T√≠tulo m√°s peque√±o -->
      <p id="error-message" style="margin-bottom:2rem; font-size:20px; font-weight:bold;"></p> <!-- Mensaje m√°s grande -->
      <button onclick="closeErrorModal()" style="background:#e5813e; color:#292626; border:none; padding:0.75rem 1.5rem; border-radius:0.5rem; cursor:pointer; font-weight:bold;">
        Close
      </button>
    </div>
  </div>
