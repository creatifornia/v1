<uc-config
Â  ctx-name="description.paints.gallery"
Â  pubkey="a4083f9a6c359a1aa43b"
Â  locale-name="es"
Â  multiple="true"
Â  multiple-max="5"
Â  group-output="false"
Â  confirm-upload="false"
Â  source-list="local, gdrive, gphotos, dropbox, onedrive"
Â  img-only="true"
Â  use-cloud-image-editor="false"
></uc-config>

<uc-file-uploader-minimal ctx-name="description.paints.gallery">
Â  <uc-form-input ctx-name="description.paints.gallery"></uc-form-input>
</uc-file-uploader-minimal>

<input
Â  type="hidden"
Â  name="description.paints.gallery"
Â  cf-json-path="description.paints.gallery"
Â  continue-trigger="continue-5"
/>

<uc-upload-ctx-provider ctx-name="description.paints.gallery"></uc-upload-ctx-provider>
<script>
customElements.whenDefined('uc-upload-ctx-provider').then(() => {
Â  setTimeout(() => {
Â  Â  const ctxProvider = document.querySelector('uc-upload-ctx-provider[ctx-name="description.paints.gallery"]');
Â  Â  if (!ctxProvider) return;

Â  Â  const storageKey = "uploadcare";
Â  Â  const pathKey = "description.paints.gallery";

Â  Â  /* ----------------- Utils ----------------- */
Â  Â  function safeParseJSON(str, fallback = null) {
Â  Â  Â  try { return JSON.parse(str); } catch (e) { return fallback; }
Â  Â  }

Â  Â  function getIdentity(detail) {
Â  Â  Â  if (!detail) return null;
Â  Â  Â  if (typeof detail === 'object') {
Â  Â  Â  Â  if (detail.uuid) return detail.uuid;
Â  Â  Â  Â  if (detail.id) return detail.id;
Â  Â  Â  Â  if (detail.file && (detail.file.uuid || detail.file.id)) return detail.file.uuid || detail.file.id;
Â  Â  Â  }
Â  Â  Â  const asString = typeof detail === 'string' ? detail : (detail && (detail.cdnUrl || detail.url || JSON.stringify(detail)));
Â  Â  Â  if (!asString) return null;
Â  Â  Â  const m = String(asString).match(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);
Â  Â  Â  return m ? m[1] : null;
Â  Â  }

Â  Â  function getFileUrl(detail) {
Â  Â  Â  if (!detail) return null;
Â  Â  Â  if (typeof detail === 'string') return detail;
Â  Â  Â  if (typeof detail === 'object') return detail.cdnUrl || detail.originalUrl || detail.url || detail.fileUrl || detail.previewUrl || null;
Â  Â  Â  return null;
Â  Â  }

Â  Â  function normalizeStoredArray(arr) {
Â  Â  Â  if (!Array.isArray(arr)) return [];
Â  Â  Â  return arr.map(item => {
Â  Â  Â  Â  if (typeof item === 'object' && item !== null && item.cdnUrl) return item;
Â  Â  Â  Â  if (typeof item === 'string') return { cdnUrl: item, uuid: getIdentity(item) };
Â  Â  Â  Â  return null;
Â  Â  Â  }).filter(Boolean);
Â  Â  }

Â  Â  function findIndexInArray(arr, incoming) {
Â  Â  Â  const incomingId = getIdentity(incoming);
Â  Â  Â  for (let i = 0; i < arr.length; i++) {
Â  Â  Â  Â  const itemId = getIdentity(arr[i]);
Â  Â  Â  Â  if (incomingId && itemId && incomingId === itemId) return i;
Â  Â  Â  }
Â  Â  Â  return -1;
Â  Â  }

Â  Â  function locateGalleryRoot() {
Â  Â  Â  return ctxProvider.closest('[uploader]') || ctxProvider.closest('.gallery') || ctxProvider.closest('form') || document;
Â  Â  }

Â  Â  function updateUploadButtonVisualByArray(arr) {
Â  Â  Â  try {
Â  Â  Â  Â  const hasFiles = Array.isArray(arr) && arr.length > 0;
Â  Â  Â  Â  const root = locateGalleryRoot();
Â  Â  Â  Â  let host = root.querySelector(`uc-file-uploader-minimal[ctx-name="${pathKey}"]`) || ctxProvider.closest('uc-file-uploader-minimal');
Â  Â  Â  Â  if (host) host.classList.toggle('uploaded', hasFiles);
Â  Â  Â  Â  const uploadBtn = root.querySelector('a[upload-button], .upload-button, button.upload-button');
Â  Â  Â  Â  if (uploadBtn) uploadBtn.classList.toggle('uploaded', hasFiles);
Â  Â  Â  } catch (err) { console.debug('updateUploadButtonVisualByArray error', err); }
Â  Â  }

Â  Â  function updateHiddenInput(arrOfObjects) {
Â  Â  Â  const hidden = locateGalleryRoot().querySelector(`input[type="hidden"][name="${pathKey}"]`);
Â  Â  Â  if (hidden) {
Â  Â  Â  Â  const urlsArray = (arrOfObjects || []).map(item => getFileUrl(item)).filter(Boolean);
Â  Â  Â  Â  hidden.value = JSON.stringify(urlsArray);
Â  Â  Â  Â  console.log("âœï¸ Hidden input actualizado (solo URLs):", hidden.value);
Â  Â  Â  Â  updateUploadButtonVisualByArray(urlsArray);
Â  Â  Â  } else {
Â  Â  Â  Â  updateUploadButtonVisualByArray(arrOfObjects || []);
Â  Â  Â  }
Â  Â  }
    
    function dispatchContinueValidation() {
        const hidden = locateGalleryRoot().querySelector(`input[type="hidden"][name="${pathKey}"]`);
        if (hidden) {
            const continueId = hidden.getAttribute("continue-trigger");
            if (continueId) {
                console.log(`ğŸ”” Disparando valid-change-hidden para: ${continueId}`);
                document.dispatchEvent(new CustomEvent("valid-change-hidden", { detail: { continueButtonId: continueId } }));
            }
        }
    }

Â  Â  /* ----------------- SUBIDA / UPDATE (CORREGIDO) ----------------- */
Â  Â  ctxProvider.addEventListener("file-url-changed", (e) => {
Â  Â  Â  const DETAILS = e.detail;
Â  Â  Â  console.log("[upload/update] file-url-changed:", DETAILS);

      // CORRECCIÃ“N: Se aÃ±ade '|| {}' para evitar que 'store' sea null.
Â  Â  Â  let store = safeParseJSON(localStorage.getItem(storageKey)) || {};
Â  Â  Â  if (!store[pathKey]) store[pathKey] = [];
Â  Â  Â  
Â  Â  Â  store[pathKey] = normalizeStoredArray(store[pathKey]);
Â  Â  Â  const idx = findIndexInArray(store[pathKey], DETAILS);
Â  Â  Â  if (idx >= 0) {
Â  Â  Â  Â  store[pathKey][idx] = Object.assign({}, store[pathKey][idx], DETAILS);
Â  Â  Â  Â  console.log("[upload/update] Actualizado en Ã­ndice", idx);
Â  Â  Â  } else {
Â  Â  Â  Â  store[pathKey].push(DETAILS);
Â  Â  Â  Â  console.log("[upload/update] Nuevo agregado");
Â  Â  Â  }
Â  Â  Â  localStorage.setItem(storageKey, JSON.stringify(store));
Â  Â  Â  updateHiddenInput(store[pathKey]);

      // CORRECCIÃ“N: Se dispara el evento de validaciÃ³n desde aquÃ­, una sola vez.
      dispatchContinueValidation();
Â  Â  });

Â  Â  /* ----------------- ELIMINACIÃ“N (CORREGIDO) ----------------- */
Â  Â  ctxProvider.addEventListener("file-removed", (e) => {
Â  Â  Â  const DETAILS = e.detail;
Â  Â  Â  console.log("[remove] file-removed:", DETAILS);
      
      // CORRECCIÃ“N: Se aÃ±ade '|| {}' para evitar que 'store' sea null.
Â  Â  Â  let store = safeParseJSON(localStorage.getItem(storageKey)) || {};
Â  Â  Â  
Â  Â  Â  if (store[pathKey] && Array.isArray(store[pathKey])) {
Â  Â  Â  Â  store[pathKey] = normalizeStoredArray(store[pathKey]);
Â  Â  Â  Â  const idx = findIndexInArray(store[pathKey], DETAILS);
Â  Â  Â  Â  if (idx >= 0) {
Â  Â  Â  Â  Â  const removedFile = store[pathKey][idx];
Â  Â  Â  Â  Â  document.dispatchEvent(new CustomEvent("delete-draft", {
Â  Â  Â  Â  Â  Â  detail: { uuid: removedFile?.uuid }
Â  Â  Â  Â  Â  }));
Â  Â  Â  Â  Â  store[pathKey].splice(idx, 1);
Â  Â  Â  Â  Â  console.log("[remove] Eliminado en Ã­ndice", idx);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (store[pathKey].length === 0) delete store[pathKey];
Â  Â  Â  Â  if (Object.keys(store).length === 0) {
Â  Â  Â  Â  Â  localStorage.removeItem(storageKey);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  localStorage.setItem(storageKey, JSON.stringify(store));
Â  Â  Â  Â  }
Â  Â  Â  Â  updateHiddenInput(store[pathKey] || []);
        
        // El evento de validaciÃ³n se dispara desde aquÃ­ al eliminar.
        dispatchContinueValidation();
Â  Â  Â  }
Â  Â  });

Â  Â  // InicializaciÃ³n
Â  Â  try {
Â  Â  Â  const formHidden = locateGalleryRoot().querySelector(`input[type="hidden"][name="${pathKey}"]`);
Â  Â  Â  const initial = formHidden ? safeParseJSON(formHidden.value, []) : [];
Â  Â  Â  updateUploadButtonVisualByArray(Array.isArray(initial) ? initial : []);
Â  Â  } catch (err) { /* silent */ }
Â  }, 100);
}).catch(err => console.error("âŒ Error Uploadcare:", err));
</script>

<script>
(() => {
Â  function getCache(key, path) {
Â  Â  try {
Â  Â  Â  const data = JSON.parse(localStorage.getItem(key));
      // Usamos optional chaining (?.) para evitar errores si data es null
Â  Â  Â  return path.split('.').reduce((acc, part) => acc?.[part], data);
Â  Â  } catch {
Â  Â  Â  return undefined;
Â  Â  }
Â  }

Â  const seenDrafts = new Set();

Â  const descriptionPaints = (fileEntry) => {
Â  Â  const MAX_SIZE_MB = 10;
Â  Â  const MAX_SIZE_BYTES = MAX_SIZE_MB * 1000 * 1000;
Â  Â  const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];
Â  Â  const DENIED_TYPES = ['image/svg+xml', 'image/gif'];

Â  Â  const ONLY_ALLOWEDÂ  Â  Â = getCache('dynamic', 'only_allowed');
Â  Â  const MAX_SIZE_TEXTÂ  Â  = getCache('dynamic', 'max_size');Â 
Â  Â  const YOUR_FILE_TEXTÂ  Â = getCache('dynamic', 'your_file');

Â  Â  // Tipo
Â  Â  if (!fileEntry.mimeType || DENIED_TYPES.includes(fileEntry.mimeType) || !ALLOWED_TYPES.includes(fileEntry.mimeType)) {
Â  Â  Â  return { message: `${ONLY_ALLOWED} JPG, PNG, WEBP o AVIF`, code: "INVALID_TYPE" };
Â  Â  }

Â  Â  // TamaÃ±o individual
Â  Â  if (fileEntry.size > MAX_SIZE_BYTES) {
Â  Â  Â  const actualSizeMB = (fileEntry.size / (1000 * 1000)).toFixed(2);
Â  Â  Â  return { message: `${MAX_SIZE_TEXT} ${MAX_SIZE_MB} MB. ${YOUR_FILE_TEXT} ${actualSizeMB} MB.`, code: "SIZE_EXCEEDED" };
Â  Â  }

Â  Â  // Evento (una vez por UUID)
Â  Â  if (fileEntry.uuid && !seenDrafts.has(fileEntry.uuid)) {
Â  Â  Â  seenDrafts.add(fileEntry.uuid);
Â  Â  Â  document.dispatchEvent(new CustomEvent("new-draft", {
Â  Â  Â  Â  detail: { fileEntry }
Â  Â  Â  }));
Â  Â  }

    // CORRECCIÃ“N: Se elimina el disparo del evento 'valid-change-hidden' de esta funciÃ³n.
    // Ahora se maneja en los listeners 'file-url-changed' y 'file-removed'.
Â  Â  return null; // La validaciÃ³n pasa
Â  };

Â  document.addEventListener('uploadcare-ready', () => {
Â  Â  customElements.whenDefined('uc-config').then(() => {
Â  Â  Â  const config = document.querySelector('uc-config[ctx-name="description.paints.gallery"]');
Â  Â  Â  if (config) config.fileValidators = [descriptionPaints];
Â  Â  });
Â  });
})();
</script>