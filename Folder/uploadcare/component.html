<script>
(function () {
  'use strict';

  // Config
  const MAX_RETRIES = 12;
  const RETRY_DELAY = 500;
  const CLICK_DELAY = 1000;

  function rectDistance(a, b) {
    const ax = a.left + a.width / 2;
    const ay = a.top + a.height / 2;
    const bx = b.left + b.width / 2;
    const by = b.top + b.height / 2;
    return Math.hypot(ax - bx, ay - by);
  }

  function findNearestWithin(root, sourceEl, selector) {
    const candidates = Array.from(root.querySelectorAll(selector));
    if (!candidates.length) return null;
    try {
      const srcRect = (sourceEl && sourceEl.getBoundingClientRect && sourceEl.getBoundingClientRect()) || { left:0,top:0,width:0,height:0 };
      let best = null;
      let bestDist = Infinity;
      for (const c of candidates) {
        const r = c.getBoundingClientRect();
        const d = rectDistance(srcRect, r);
        if (d < bestDist) { bestDist = d; best = c; }
      }
      return best;
    } catch (err) {
      return candidates[0] || null;
    }
  }

  function safeClick(el) {
    if (!el) return false;
    try { el.click(); return true; } catch (_) {
      try { el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true })); } catch(e){}
      try { el.dispatchEvent(new MouseEvent('mouseup',   { bubbles: true, cancelable: true })); } catch(e){}
      try { el.dispatchEvent(new MouseEvent('click',     { bubbles: true, cancelable: true })); return true; } catch (e) {
        console.error('safeClick failed', e, el);
        return false;
      }
    }
  }

  async function processUploader(uploaderEl, idx) {
    if (!uploaderEl || uploaderEl.__processed) return { success: false, reason: 'already' };
    let attempt = 0;

    while (attempt <= MAX_RETRIES) {
      attempt++;
      try {
        const uploadButton = uploaderEl.querySelector('[upload-button]');
        const doneButton   = uploaderEl.querySelector('button.uc-done-btn.uc-primary-btn');
        const cancelNative = uploaderEl.querySelector('button.uc-cancel-btn.uc-secondary-btn'); // original "Limpiar" if present
        const closeBtn     = uploaderEl.querySelector('button.uc-mini-btn.uc-close-btn');

        // new: generic secondary button (e.g. "Cancelar") that should behave like "Hecho" (cancel its native behavior)
        const secondaryBtn = Array.from(uploaderEl.querySelectorAll('button.uc-secondary-btn'))
                                  .find(b => !b.classList.contains('uc-cancel-btn') && !b.classList.contains('uc-done-btn'));

        const sourceForNearest = uploadButton || uploaderEl;
        const uploaderTab = findNearestWithin(uploaderEl, sourceForNearest, '[uploader-tab]');
        const buttonTab   = findNearestWithin(uploaderEl, sourceForNearest, '[button-tab]');
        const dropArea    = findNearestWithin(uploaderEl, sourceForNearest, 'uc-drop-area[clickable], uc-drop-area[initflow], uc-drop-area');

        const missing = [];
        if (!uploadButton) missing.push('upload-button');
        if (!uploaderTab)    missing.push('uploader-tab');
        if (!dropArea)       missing.push('uc-drop-area');

        if (missing.length) {
          console.log(`[uploader ${idx}] attempt ${attempt}: missing ${missing.join(', ')}`);
          if (attempt <= MAX_RETRIES) {
            await new Promise(r => setTimeout(r, RETRY_DELAY));
            continue;
          } else {
            console.error(`[uploader ${idx}] giving up after ${attempt-1} attempts; missing: ${missing.join(', ')}`);
            return { success: false, reason: 'missing', missing };
          }
        }

        // Remove original cancel & close buttons (destroy/hide)
        try {
          if (cancelNative) cancelNative.remove();
          if (closeBtn)     closeBtn.remove();
        } catch (e) {
          if (cancelNative) { cancelNative.style.display = 'none'; cancelNative.setAttribute('aria-hidden','true'); }
          if (closeBtn)     { closeBtn.style.display = 'none'; closeBtn.setAttribute('aria-hidden','true'); }
        }

        // upload-button handler: uploader-tab -> wait -> drop-area
        const uploadHandler = (ev) => {
          try { ev?.stopImmediatePropagation?.(); ev?.preventDefault?.(); } catch(e){}
          try {
            console.log(`[uploader ${idx}] upload-button clicked; performing uploader-tab -> drop-area sequence`);
            safeClick(uploaderTab);
            setTimeout(() => { safeClick(dropArea); }, CLICK_DELAY);
          } catch (err) {
            console.error(`[uploader ${idx}] error during upload-button handler:`, err);
          }
        };
        if (uploadButton && !uploadButton.__uploader_hooked) {
          uploadButton.addEventListener('click', uploadHandler, { capture: true });
          uploadButton.__uploader_hooked = true;
        }

        // DONE button handler: programmatically click the nearest [button-tab], then open drop-area
        if (doneButton) {
          if (!doneButton.__uploader_hijacked) {
            doneButton.__uploader_hijacked = true;
            doneButton.addEventListener('click', (ev) => {
              try { ev.preventDefault?.(); ev.stopImmediatePropagation?.(); } catch(e){}
              let targetButtonTab = findNearestWithin(uploaderEl, doneButton, '[button-tab]');
              if (!targetButtonTab) targetButtonTab = uploaderEl.querySelector('[button-tab]');
              if (targetButtonTab) {
                console.log(`[uploader ${idx}] Hecho -> clicking nearest [button-tab]`, targetButtonTab);
                try { targetButtonTab.click(); } catch (err) {
                  try {
                    targetButtonTab.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true }));
                    targetButtonTab.dispatchEvent(new MouseEvent('mouseup',   { bubbles: true, cancelable: true }));
                    targetButtonTab.dispatchEvent(new MouseEvent('click',     { bubbles: true, cancelable: true }));
                  } catch (err2) { console.error('failed programmatic click on button-tab', err2); }
                }
                setTimeout(() => {
                  try { safeClick(dropArea); } catch(e) { console.error('dropArea click failed after Hecho', e); }
                }, Math.max(120, CLICK_DELAY - 800));
              } else {
                console.warn(`[uploader ${idx}] Hecho clicked but no [button-tab] found inside uploader`);
              }
            }, { capture: true });
          }
        }

        // NEW: secondary button (e.g. "Cancelar") â€” cancel native behavior and behave like "Hecho"
        if (secondaryBtn) {
          if (!secondaryBtn.__secondary_hijacked) {
            secondaryBtn.__secondary_hijacked = true;
            secondaryBtn.addEventListener('click', (ev) => {
              try { ev.preventDefault?.(); ev.stopImmediatePropagation?.(); } catch(e){}
              let targetButtonTab = findNearestWithin(uploaderEl, secondaryBtn, '[button-tab]');
              if (!targetButtonTab) targetButtonTab = uploaderEl.querySelector('[button-tab]');
              if (targetButtonTab) {
                console.log(`[uploader ${idx}] Cancel (secondary) -> clicking nearest [button-tab]`, targetButtonTab);
                try { targetButtonTab.click(); } catch (err) {
                  try {
                    targetButtonTab.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true }));
                    targetButtonTab.dispatchEvent(new MouseEvent('mouseup',   { bubbles: true, cancelable: true }));
                    targetButtonTab.dispatchEvent(new MouseEvent('click',     { bubbles: true, cancelable: true }));
                  } catch (err2) { console.error('failed programmatic click on button-tab from secondary', err2); }
                }
                setTimeout(() => {
                  try { safeClick(dropArea); } catch(e) { console.error('dropArea click failed after secondary', e); }
                }, Math.max(120, CLICK_DELAY - 800));
              } else {
                console.warn(`[uploader ${idx}] Cancel (secondary) clicked but no [button-tab] found inside uploader`);
              }
            }, { capture: true });
          }
        }

        // [close] elements treated like direct Hecho-like click but without cancelling their native behavior (kept as before)
        const closeAttrEls = Array.from(uploaderEl.querySelectorAll('[close]'));
        closeAttrEls.forEach(cl => {
          if (cl.__close_hooked) return;
          cl.__close_hooked = true;
          cl.addEventListener('click', (ev) => {
            try { ev.preventDefault?.(); ev.stopImmediatePropagation?.(); } catch(e){}
            let targetButtonTab = findNearestWithin(uploaderEl, cl, '[button-tab]');
            if (!targetButtonTab) targetButtonTab = uploaderEl.querySelector('[button-tab]');
            if (targetButtonTab) {
              console.log(`[uploader ${idx}] [close] clicked -> clicking nearest [button-tab]`, targetButtonTab);
              try { targetButtonTab.click(); } catch (err) {
                try {
                  targetButtonTab.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true }));
                  targetButtonTab.dispatchEvent(new MouseEvent('mouseup',   { bubbles: true, cancelable: true }));
                  targetButtonTab.dispatchEvent(new MouseEvent('click',     { bubbles: true, cancelable: true }));
                } catch (err2) { console.error('failed programmatic click on button-tab from [close]', err2); }
              }
              setTimeout(() => {
                try { safeClick(dropArea); } catch(e) { console.error('dropArea click failed after [close]', e); }
              }, Math.max(120, CLICK_DELAY - 800));
            } else {
              console.warn(`[uploader ${idx}] [close] clicked but no [button-tab] found inside uploader`);
            }
          }, { capture: true });
        });

        // button-tab handler: intercept USER clicks only to run dropArea->uploaderTab; let programmatic clicks do native navigation
        const allButtonTabs = Array.from(uploaderEl.querySelectorAll('[button-tab]'));
        allButtonTabs.forEach(bt => {
          if (bt.__uploader_button_tab_hooked) return;
          bt.addEventListener('click', (ev) => {
            if (!ev.isTrusted) {
              console.log(`[uploader ${idx}] programmatic [button-tab] click: letting native behavior run`);
              return;
            }
            try { ev.preventDefault?.(); ev.stopImmediatePropagation?.(); } catch(e){}
            console.log(`[uploader ${idx}] [button-tab] clicked by user -> running dropArea then uploaderTab`);
            safeClick(dropArea);
            setTimeout(() => { safeClick(uploaderTab); }, CLICK_DELAY);
          }, { capture: true });
          bt.__uploader_button_tab_hooked = true;
        });

        uploaderEl.__processed = true;
        console.log(`[uploader ${idx}] processed successfully`);
        return { success: true };
      } catch (err) {
        console.error(`[uploader ${idx}] unexpected error on attempt ${attempt}:`, err);
        if (attempt <= MAX_RETRIES) { await new Promise(r => setTimeout(r, RETRY_DELAY)); continue; }
        return { success: false, reason: 'exception', error: String(err) };
      }
    }
    return { success: false, reason: 'exhausted' };
  }

  function startProcessing() {
    const uploaders = Array.from(document.querySelectorAll('div[uploader]'));
    const total = uploaders.length;
    console.log('Found uploader count:', total);

    let processed = 0;
    let failed = 0;
    (async () => {
      for (let i = 0; i < uploaders.length; i++) {
        const res = await processUploader(uploaders[i], i + 1);
        if (res.success) processed++; else failed++;
      }
      console.log('Uploader processing complete. total:', total, 'processed:', processed, 'failed:', failed);
      document.dispatchEvent(new CustomEvent('buttons-ready', { detail: { total, processed, failed } }));
    })();
  }

  document.addEventListener('uploadcare-ready', () => {
    customElements.whenDefined('uc-config').then(() => {
      try {
        startProcessing();
      } catch (e) {
        console.error('Error starting uploader processing:', e);
        document.dispatchEvent(new CustomEvent('buttons-ready', { detail: { total: 0, processed: 0, failed: 0, error: String(e) } }));
      }
    });
  });
})();
</script>
