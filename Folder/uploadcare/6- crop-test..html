<!-- ‚úÖ Uploadcare Config -->
<!--overview.main-image-->
<!--overviewMain-->
<!--continue-trigger="continue-5"-->
<uc-config
  ctx-name="overview.main-image"
  pubkey="a4083f9a6c359a1aa43b"
  locale-name="es"
  multiple="true"
  multiple-max="5"
  group-output="false"
  confirm-upload="false"
  source-list="local, gdrive, gphotos, dropbox, onedrive"
  img-only="true"
  use-cloud-image-editor="true"
  cloud-image-editor-tabs="crop"
  crop-preset="1:1"
></uc-config>

<!-- ‚úÖ Uploadcare File Uploader -->
<uc-file-uploader-minimal ctx-name="overview.main-image">
  <uc-form-input ctx-name="overview.main-image"></uc-form-input>
</uc-file-uploader-minimal>

<!-- ‚úÖ Hidden Input vinculado -->
<input
  type="hidden"
  name="overview.main-image"
  cf-json-path="overview.main-image"
  continue-trigger="continue-5"
  data-required=""
  always-required=""
/>

<!-- ‚úÖ Uploadcare Context Listener -->
<uc-upload-ctx-provider ctx-name="overview.main-image"></uc-upload-ctx-provider>
<script>
customElements.whenDefined('uc-upload-ctx-provider').then(() => {
  setTimeout(() => {
    const ctxProvider = document.querySelector('uc-upload-ctx-provider[ctx-name="overview.main-image"]');
    if (!ctxProvider) return;

    const storageKey = "uploadcare";
    const pathKey = "overview.main-image";

    /* ----------------- Utils ----------------- */
    function safeParseJSON(str, fallback = null) {
      try { return JSON.parse(str); } catch (e) { return fallback; }
    }

    function getIdentity(detail) {
      if (!detail) return null;
      if (typeof detail === 'object') {
        if (detail.uuid) return detail.uuid;
        if (detail.id) return detail.id;
        if (detail.file && (detail.file.uuid || detail.file.id)) return detail.file.uuid || detail.file.id;
      }
      const asString = typeof detail === 'string'
        ? detail
        : (detail && (detail.cdnUrl || detail.url || JSON.stringify(detail)));
      if (!asString) return null;
      const m = String(asString).match(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);
      return m ? m[1] : null;
    }

    function getFileUrl(detail) {
      if (!detail) return null;
      if (typeof detail === 'string') return detail;
      if (typeof detail === 'object') {
        return detail.cdnUrl || detail.originalUrl || detail.url || detail.fileUrl || detail.previewUrl || null;
      }
      return null;
    }

    function normalizeStoredArray(arr) {
      if (!Array.isArray(arr)) return [];
      return arr.map(item => {
        if (typeof item === 'string') return { url: item };
        if (typeof item === 'object' && item !== null) return item;
        return { value: item };
      }).filter(Boolean);
    }

    function findIndexInArray(arr, incoming) {
      const incomingId = getIdentity(incoming);
      const incomingUrl = getFileUrl(incoming);
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const itemId = getIdentity(item);
        const itemUrl = getFileUrl(item);
        if (incomingId && itemId && incomingId === itemId) return i;
        if (!incomingId && incomingUrl && itemUrl && incomingUrl === itemUrl) return i;
      }
      return -1;
    }

    /**
     * Encuentra el "gallery root" relativo al ctxProvider para operar localmente.
     * Prioriza: ancestor con atributo [uploader], luego .gallery, luego form, luego document.
     */
    function locateGalleryRoot() {
      return ctxProvider.closest('[uploader]') || ctxProvider.closest('.gallery') || ctxProvider.closest('form') || document;
    }

    /**
     * Actualiza la clase 'uploaded' en elementos relevantes **dentro** del gallery root:
     *  - <uc-file-uploader-minimal[ctx-name=...]> (host)
     *  - a[upload-button] o .upload-button (light DOM)
     *
     * hasFiles = true => a√±adir clase uploaded
     * hasFiles = false => quitar clase uploaded
     */
    function updateUploadButtonVisualByArray(arr) {
      try {
        const hasFiles = Array.isArray(arr) && arr.length > 0;
        const root = locateGalleryRoot();

        // 1) host uploader (si existe dentro del root)
        let host = root.querySelector(`uc-file-uploader-minimal[ctx-name="${pathKey}"]`);
        // fallback: el ctxProvider puede estar dentro del host -> buscar ancestor host
        if (!host) host = ctxProvider.closest('uc-file-uploader-minimal');

        if (host && host.classList) host.classList.toggle('uploaded', hasFiles);

        // 2) upload-button dentro del mismo gallery root (no global)
        const uploadBtn = root.querySelector('a[upload-button], .upload-button, button.upload-button');
        if (uploadBtn && uploadBtn.classList) uploadBtn.classList.toggle('uploaded', hasFiles);

      } catch (err) {
        // no queremos romper nada por temas de visual toggle
        console.debug('updateUploadButtonVisualByArray error', err);
      }
    }

    /* ----------------- updateHiddenInput (mantiene store y actualiza visual) ----------------- */
    function updateHiddenInput(arr) {
      const hidden = ctxProvider.closest("form")?.querySelector(`input[type="hidden"][name="${pathKey}"]`) 
                  || ctxProvider.closest(locateGalleryRoot())?.querySelector(`input[type="hidden"][name="${pathKey}"]`);
      if (hidden) {
        try { hidden.value = JSON.stringify(arr || []); } catch (e) { hidden.value = '[]'; }
        console.log("‚úèÔ∏è Hidden input actualizado:", hidden.value);
        const parsed = safeParseJSON(hidden.value, []);
        updateUploadButtonVisualByArray(Array.isArray(parsed) ? parsed : []);
      } else {
        // si no existe hidden, a√∫n actualizamos la visual bas√°ndonos en arr
        updateUploadButtonVisualByArray(Array.isArray(arr) ? arr : []);
      }
    }

    /* ----------------- SUBIDA / UPDATE ----------------- */
    ctxProvider.addEventListener("file-url-changed", (e) => {
      const DETAILS = e.detail;
      console.log("[upload/update] file-url-changed:", DETAILS);

      let store = {};
      try { store = JSON.parse(localStorage.getItem(storageKey)) || {}; } catch { store = {}; }

      if (!store[pathKey]) store[pathKey] = [];
      store[pathKey] = normalizeStoredArray(store[pathKey]);

      const idx = findIndexInArray(store[pathKey], DETAILS);

      if (idx >= 0) {
        const existing = store[pathKey][idx];
        const merged = Object.assign({}, existing, DETAILS);
        store[pathKey][idx] = merged;
        console.log("[upload/update] Actualizado en √≠ndice", idx);
      } else {
        store[pathKey].push(DETAILS);
        console.log("[upload/update] Nuevo agregado");
      }

      localStorage.setItem(storageKey, JSON.stringify(store));
      updateHiddenInput(store[pathKey]);
    });

    /* ----------------- ELIMINACI√ìN ----------------- */
    ctxProvider.addEventListener("file-removed", (e) => {
      const DETAILS = e.detail;
      console.log("[remove] file-removed:", DETAILS);

      let store = {};
      try { store = JSON.parse(localStorage.getItem(storageKey)) || {}; } catch { store = {}; }

      if (store[pathKey] && Array.isArray(store[pathKey])) {
        store[pathKey] = normalizeStoredArray(store[pathKey]);
        const idx = findIndexInArray(store[pathKey], DETAILS);
        if (idx >= 0) {
          const removedFile = store[pathKey][idx];
          document.dispatchEvent(new CustomEvent("delete-draft", {
            detail: { uuid: removedFile?.uuid, size: removedFile?.size }
          }));

          store[pathKey].splice(idx, 1);
          console.log("[remove] Eliminado en √≠ndice", idx);
        }

        if (store[pathKey].length === 0) delete store[pathKey];
        if (Object.keys(store).length === 0) {
          localStorage.removeItem(storageKey);
        } else {
          localStorage.setItem(storageKey, JSON.stringify(store));
        }

        updateHiddenInput(store[pathKey] || []);

        // üîî Emitimos valid-change-hidden SOLO si el hidden tiene continue-trigger
        const hidden = ctxProvider.closest("form")?.querySelector(`input[type="hidden"][name="${pathKey}"]`);
        if (hidden) {
          const continueId = hidden.getAttribute("continue-trigger");
          if (continueId) {
            document.dispatchEvent(new CustomEvent("valid-change-hidden", {
              detail: { continueButtonId: continueId }
            }));
          }
        }
      }
    });

    // Inicial: sincronizar visual seg√∫n el hidden actual (por si ya hay archivos en el DOM)
    try {
      const formHidden = ctxProvider.closest("form")?.querySelector(`input[type="hidden"][name="${pathKey}"]`);
      const initial = formHidden ? safeParseJSON(formHidden.value, []) : [];
      updateUploadButtonVisualByArray(Array.isArray(initial) ? initial : []);
    } catch (err) { /* silent */ }

  }, 100);
}).catch(err => console.error("‚ùå Error Uploadcare:", err));
</script>


<!-- ‚úÖ Validation -->
<script>
(() => {
  function getCache(key, path) {
    try {
      const data = JSON.parse(localStorage.getItem(key));
      return path.split('.').reduce((acc, part) => acc?.[part], data);
    } catch {
      return undefined;
    }
  }

  const seenDrafts = new Set();

  const overviewMain = (fileEntry) => {
    const MAX_SIZE_MB = 10;
    const MAX_SIZE_BYTES = MAX_SIZE_MB * 1000 * 1000;
    const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];
    const DENIED_TYPES = ['image/svg+xml', 'image/gif'];

    const STORAGE_CAPACITY = getCache('offices', 'club.storage_bites');
    const STORAGE_USED     = getCache('offices', 'club.storage_used_bites');
    const ONLY_ALLOWED     = getCache('dynamic', 'only_allowed');
    const MAX_SIZE_TEXT    = getCache('dynamic', 'max_size'); 
    const YOUR_FILE_TEXT   = getCache('dynamic', 'your_file');
    const NEED_STORAGE     = getCache('dynamic', 'need_storage');

    // Tipo
    if (!fileEntry.mimeType || DENIED_TYPES.includes(fileEntry.mimeType)) {
      return { message: `${ONLY_ALLOWED} JPG, PNG, WEBP o AVIF`, code: "INVALID_TYPE" };
    }
    if (!ALLOWED_TYPES.includes(fileEntry.mimeType)) {
      return { message: `${ONLY_ALLOWED} JPG, PNG, WEBP o AVIF`, code: "INVALID_TYPE" };
    }

    // Tama√±o individual
    if (fileEntry.size > MAX_SIZE_BYTES) {
      const actualSizeMB = (fileEntry.size / (1000 * 1000)).toFixed(2);
      return { message: `${MAX_SIZE_TEXT} ${MAX_SIZE_MB} MB. ${YOUR_FILE_TEXT} ${actualSizeMB} MB.`, code: "SIZE_EXCEEDED" };
    }

    // Proyecci√≥n de uso (solo interna, NO se env√≠a en el evento)
    const projectedTotal = (typeof STORAGE_USED === "number") ? (STORAGE_USED + fileEntry.size) : undefined;

    // Validaci√≥n de capacidad (solo si hay ambos n√∫meros)
    if (typeof STORAGE_CAPACITY === "number" && typeof STORAGE_USED === "number") {
      if (projectedTotal > STORAGE_CAPACITY) {
        return {
          message: `${NEED_STORAGE}`,
          code: "STORAGE_INSUFFICIENT"
        };
      }
    }

    // Evento (una vez por UUID) -> SOLO fileEntry en detail
    if (fileEntry.uuid && !seenDrafts.has(fileEntry.uuid)) {
      seenDrafts.add(fileEntry.uuid);
      document.dispatchEvent(new CustomEvent("new-draft", {
        detail: { fileEntry }
      }));
    }

    // üîπ Selecci√≥n directa al hidden input vinculado
    const hiddenInput = document.querySelector('input[type="hidden"][cf-json-path="overview.main-image"]');

    if (hiddenInput) {
      const continueButtonId = hiddenInput.getAttribute("continue-trigger");
      if (continueButtonId) {
        document.dispatchEvent(new CustomEvent("valid-change-hidden", {
          detail: { continueButtonId }
        }));
        return null; // detenemos aqu√≠
      }
    }

    return null;
  };

  document.addEventListener('uploadcare-ready', () => {
    customElements.whenDefined('uc-config').then(() => {
      const config = document.querySelector('uc-config[ctx-name="overview.main-image"]');
      if (config) config.fileValidators = [overviewMain];
    });
  });
})();
</script>