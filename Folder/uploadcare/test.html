<!-- ‚úÖ Uploadcare Config -->
<uc-config
  ctx-name="kits-details-paints"
  pubkey="a4083f9a6c359a1aa43b"
  locale-name="es"
  multiple="true"
  multiple-max="5"
  group-output="true"
  confirm-upload="false"
  source-list="local, gdrive, gphotos, dropbox, onedrive"
  img-only="true"
  use-cloud-image-editor="true"
  crop-preset="1:1"
  cloud-image-editor-tabs="crop"


></uc-config>

<!-- ‚úÖ Uploadcare File Uploader -->
<uc-file-uploader-minimal ctx-name="kits-details-paints">
  <uc-form-input ctx-name="kits-details-paints"></uc-form-input>
</uc-file-uploader-minimal>

<!-- ‚úÖ Hidden Input vinculado con validaci√≥n personalizada -->
<input
  type="hidden"
  name="kits-details-paints"
  cf-local-storage-key="uploadcare"
  cf-local-storage-path="kits-details.paints"
  cf-json-path="kits-details-paints"
  cf-form-submit-identifier="publish-sesion-kids" 

/>

<script>
  customElements.whenDefined("uc-upload-ctx-provider").then(() => {
    setTimeout(() => {
      const ctxProvider = document.querySelector('uc-upload-ctx-provider[ctx-name="kits-details-paints"]');
      if (!ctxProvider) return;

      const storageKey = "uploadcare";

      // --- helpers para manejar objeto anidado en localStorage ---
      function getNested(obj, path) {
        return path.split(".").reduce((acc, key) => acc?.[key], obj);
      }
      function setNested(obj, path, value) {
        const keys = path.split(".");
        let cur = obj;
        keys.forEach((k, i) => {
          if (i === keys.length - 1) {
            cur[k] = value;
          } else {
            if (!cur[k] || typeof cur[k] !== "object") cur[k] = {};
            cur = cur[k];
          }
        });
      }
      function deleteNested(obj, path) {
        const keys = path.split(".");
        let cur = obj;
        keys.forEach((k, i) => {
          if (i === keys.length - 1) {
            delete cur[k];
          } else {
            if (!cur[k]) return;
            cur = cur[k];
          }
        });
      }

      // --- helpers de identidad ---
      function getIdentity(detail) {
        if (!detail) return null;
        if (typeof detail === "object") {
          if (detail.uuid) return detail.uuid;
          if (detail.id) return detail.id;
          if (detail.file && (detail.file.uuid || detail.file.id))
            return detail.file.uuid || detail.file.id;
        }
        const asString =
          typeof detail === "string"
            ? detail
            : detail && (detail.cdnUrl || detail.url || JSON.stringify(detail));
        if (!asString) return null;
        const uuidMatch = String(asString).match(
          /([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i
        );
        return uuidMatch ? uuidMatch[1] : null;
      }
      function getFileUrl(detail) {
        if (!detail) return null;
        if (typeof detail === "string") return detail;
        if (typeof detail === "object") {
          return (
            detail.cdnUrl ||
            detail.originalUrl ||
            detail.url ||
            detail.fileUrl ||
            detail.previewUrl ||
            null
          );
        }
        return null;
      }
      function normalizeStoredArray(arr) {
        if (!Array.isArray(arr)) return [];
        return arr.map((item) => {
          if (typeof item === "string") return { url: item };
          if (typeof item === "object" && item !== null) return item;
          return { value: item };
        });
      }
      function findIndexInArray(arr, incoming) {
        const incomingId = getIdentity(incoming);
        const incomingUrl = getFileUrl(incoming);
        for (let i = 0; i < arr.length; i++) {
          const item = arr[i];
          const itemId = getIdentity(item);
          const itemUrl = getFileUrl(item);
          if (incomingId && itemId && incomingId === itemId) return i;
          if (!incomingId && incomingUrl && itemUrl && incomingUrl === itemUrl) return i;
        }
        return -1;
      }

      // --- actualizar el hidden input ---
      function updateHiddenInput(jsonPath, value) {
        const hidden = document.querySelector(
          `input[type="hidden"][cf-json-path="${jsonPath}"]`
        );
        if (hidden) {
          hidden.value = JSON.stringify(value || []);
          hidden.dispatchEvent(new Event("input", { bubbles: true }));
          hidden.dispatchEvent(new Event("change", { bubbles: true }));
          console.log("üì• Hidden actualizado:", jsonPath, hidden.value);
        }
      }

      // ----------------- event: subir / update -----------------
      ctxProvider.addEventListener("file-url-changed", (e) => {
        const DETAILS = e.detail;
        console.log("[upload/update] file-url-changed detail:", DETAILS);

        const wrapper = ctxProvider.closest("[uploader]");
        if (!wrapper) return;
        const uploaderAttr = wrapper.getAttribute("uploader");
        const uploaderName = wrapper.getAttribute("name");
        const jsonPath = wrapper.getAttribute("json-path");
        if (!jsonPath) return;

        let store = {};
        try {
          store = JSON.parse(localStorage.getItem(storageKey)) || {};
        } catch {}

        let arr = getNested(store, jsonPath) || [];
        arr = normalizeStoredArray(arr);

        const idx = findIndexInArray(arr, DETAILS);
        if (idx >= 0) {
          const merged = Object.assign({}, arr[idx], DETAILS);
          arr[idx] = merged;
          console.log("[upload/update] Actualizada entrada existente", idx);
        } else {
          arr.push(DETAILS);
          console.log("[upload/update] Nueva entrada a√±adida");
        }

        setNested(store, jsonPath, arr);
        localStorage.setItem(storageKey, JSON.stringify(store));
        updateHiddenInput(jsonPath, arr);
      });

      // ----------------- event: remover -----------------
      ctxProvider.addEventListener("file-removed", (e) => {
        const DETAILS = e.detail;
        console.log("[remove] file-removed detail:", DETAILS);

        const wrapper = ctxProvider.closest("[uploader]");
        if (!wrapper) return;
        const jsonPath = wrapper.getAttribute("json-path");
        if (!jsonPath) return;

        let store = {};
        try {
          store = JSON.parse(localStorage.getItem(storageKey)) || {};
        } catch {}

        let arr = getNested(store, jsonPath) || [];
        arr = normalizeStoredArray(arr);

        const idx = findIndexInArray(arr, DETAILS);
        if (idx >= 0) {
          arr.splice(idx, 1);
          console.log("[remove] Eliminada entrada en √≠ndice", idx);
        }

        if (arr.length === 0) {
          deleteNested(store, jsonPath);
        } else {
          setNested(store, jsonPath, arr);
        }

        if (Object.keys(store).length === 0) {
          localStorage.removeItem(storageKey);
        } else {
          localStorage.setItem(storageKey, JSON.stringify(store));
        }
        updateHiddenInput(jsonPath, arr);
      });
    }, 100);
  });
</script>






<!-- ‚úÖ Image size validator-->
<script>
  const imageValidator9 = (fileEntry) => {
    // Configuraci√≥n
    const MAX_SIZE_MB = 1;
    const MAX_SIZE_BYTES = MAX_SIZE_MB * 1024 * 1024;
    const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];
    const DENIED_TYPES = ['image/svg+xml', 'image/gif'];

    // 1. Validar tipo de archivo
    if (!fileEntry.mimeType || DENIED_TYPES.includes(fileEntry.mimeType)) {
      return {
        message: "No se aceptan SVG ni GIF. Solo JPG, PNG, WEBP o AVIF",
        code: "INVALID_TYPE"
      };
    }

    if (!ALLOWED_TYPES.includes(fileEntry.mimeType)) {
      return {
        message: "Solo se permiten im√°genes JPG, PNG, WEBP o AVIF",
        code: "INVALID_TYPE"
      };
    }

    // 2. Validar tama√±o
    if (fileEntry.size > MAX_SIZE_BYTES) {
      const actualSizeMB = (fileEntry.size / (1024 * 1024)).toFixed(2);
      return {
        message: `Tama√±o m√°ximo: ${MAX_SIZE_MB}MB (subes: ${actualSizeMB}MB)`,
        code: "SIZE_EXCEEDED"
      };
    }

    return null; // Archivo v√°lido
  };

  // Configuraci√≥n del validador
  document.addEventListener('uploadcare-ready', () => {
    customElements.whenDefined('uc-config').then(() => {
      const config = document.querySelector('uc-config[ctx-name="kits-details-paints"]');
      if (config) config.fileValidators = [imageValidator9];
    });
  });
</script>



<!-- EMBED CODE -->


instrucciones:
ocultar este elemento
<button type="button" class="uc-mini-btn uc-close-btn" title="Cerrar" aria-label="Cerrar"><uc-icon name="close" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg"><use href="#uc-icon-close"></use></svg></uc-icon></button>



<script>
document.addEventListener("DOMContentLoaded", () => {
  const btnUpload = document.getElementById("upload");
  if (!btnUpload) return;

  btnUpload.addEventListener("click", () => {
    // Busca el <uc-drop-area> m√°s cercano dentro del mismo contenedor o hacia arriba
    const dropArea = btnUpload.closest("form, body").querySelector("uc-drop-area"); 
    if (dropArea) {
      dropArea.click(); //agregamos un click posterior en el elemento m√°s proximo con atributo go-to-uploader
    } else {
      console.warn("‚ö†Ô∏è No se encontr√≥ uc-drop-area para activar.");
    }
  });
});
</script> 

dentro de este toolbar, clonamos un boton 
<div class="uc-toolbar"><button type="button" class="uc-cancel-btn uc-secondary-btn">Limpiar</button><div class="uc-toolbar-spacer"></div><button type="button" class="uc-add-more-btn uc-secondary-btn"><uc-icon name="add" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg"><use href="#uc-icon-add"></use></svg></uc-icon><span>A√±adir m√°s</span></button><button type="button" class="uc-upload-btn uc-primary-btn" hidden="">Subir</button><button type="button" class="uc-done-btn uc-primary-btn">Hecho</button></div>

especificamente este (me refiero al estilo, lo ubicamos alli mismo dentro de uc-toolbar junto a este<button type="button" class="uc-add-more-btn uc-secondary-btn"><uc-icon name="add" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg"><use href="#uc-icon-add"></use></svg></uc-icon><span>A√±adir m√°s</span></button>)

le agregamos el atributo :
cf= "save"
save= ""


cuando se hace click en el, se dispara un evento con toda la informaci√≥n (el array que actualmente se guarda en local storage)