<!-- ‚úÖ Uploadcare Config -->
<uc-config
  ctx-name="kits-details.paints"
  pubkey="a4083f9a6c359a1aa43b"
  locale-name="es"
  multiple="true"
  multiple-max="5"
  group-output="false"
  confirm-upload="false"
  source-list="local, gdrive, gphotos, dropbox, onedrive"
  img-only="true"
  use-cloud-image-editor="false"
  crop-preset=""
  cloud-image-editor-tabs="crop"
></uc-config>

<!-- ‚úÖ Uploadcare File Uploader -->
<uc-file-uploader-minimal ctx-name="kits-details.paints">
  <uc-form-input ctx-name="kits-details.paints"></uc-form-input>
</uc-file-uploader-minimal>

<!-- ‚úÖ Hidden Input vinculado -->
<input
  type="hidden"
  name="kits-details.paints"
  cf-json-path="kits-details.paints"
/>

<!-- ‚úÖ Uploadcare Context Listener -->
<uc-upload-ctx-provider ctx-name="kits-details.paints"></uc-upload-ctx-provider>
<script>
  customElements.whenDefined('uc-upload-ctx-provider').then(() => {
    setTimeout(() => {
      const ctxProvider = document.querySelector(
        'uc-upload-ctx-provider[ctx-name="kits-details.paints"]'
      );
      if (!ctxProvider) return;

      const storageKey = "uploadcare";
      const pathKey = "kits-details.paints";

      /* ----------------- Utils ----------------- */
      function getIdentity(detail) {
        if (!detail) return null;
        if (typeof detail === 'object') {
          if (detail.uuid) return detail.uuid;
          if (detail.id) return detail.id;
          if (detail.file && (detail.file.uuid || detail.file.id)) {
            return detail.file.uuid || detail.file.id;
          }
        }
        const asString =
          typeof detail === 'string'
            ? detail
            : (detail && (detail.cdnUrl || detail.url || JSON.stringify(detail)));
        if (!asString) return null;
        const uuidMatch = String(asString).match(
          /([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i
        );
        return uuidMatch ? uuidMatch[1] : null;
      }

      function getFileUrl(detail) {
        if (!detail) return null;
        if (typeof detail === 'string') return detail;
        if (typeof detail === 'object') {
          return (
            detail.cdnUrl ||
            detail.originalUrl ||
            detail.url ||
            detail.fileUrl ||
            detail.previewUrl ||
            null
          );
        }
        return null;
      }

      function normalizeStoredArray(arr) {
        if (!Array.isArray(arr)) return [];
        return arr
          .map(item => {
            if (typeof item === 'string') return { url: item };
            if (typeof item === 'object' && item !== null) return item;
            return { value: item };
          })
          .filter(Boolean);
      }

      function findIndexInArray(arr, incoming) {
        const incomingId = getIdentity(incoming);
        const incomingUrl = getFileUrl(incoming);
        for (let i = 0; i < arr.length; i++) {
          const item = arr[i];
          const itemId = getIdentity(item);
          const itemUrl = getFileUrl(item);
          if (incomingId && itemId && incomingId === itemId) return i;
          if (!incomingId && incomingUrl && itemUrl && incomingUrl === itemUrl) return i;
        }
        return -1;
      }

      function updateHiddenInput(arr) {
        const hidden = ctxProvider.closest("form")?.querySelector(
          `input[type="hidden"][name="${pathKey}"]`
        );
        if (hidden) {
          hidden.value = JSON.stringify(arr);
          console.log("‚úèÔ∏è Hidden input actualizado:", hidden.value);
        }
      }

      /* ----------------- SUBIDA / UPDATE ----------------- */
      ctxProvider.addEventListener("file-url-changed", (e) => {
        const DETAILS = e.detail;
        console.log("[upload/update] file-url-changed:", DETAILS);

        let store = {};
        try {
          store = JSON.parse(localStorage.getItem(storageKey)) || {};
        } catch {
          store = {};
        }

        if (!store[pathKey]) store[pathKey] = [];
        store[pathKey] = normalizeStoredArray(store[pathKey]);

        const idx = findIndexInArray(store[pathKey], DETAILS);

        if (idx >= 0) {
          const existing = store[pathKey][idx];
          const merged = Object.assign({}, existing, DETAILS);
          store[pathKey][idx] = merged;
          console.log("[upload/update] Actualizado en √≠ndice", idx);
        } else {
          store[pathKey].push(DETAILS);
          console.log("[upload/update] Nuevo agregado");
        }

        localStorage.setItem(storageKey, JSON.stringify(store));
        updateHiddenInput(store[pathKey]);
      });
/* ----------------- ELIMINACI√ìN ----------------- */
ctxProvider.addEventListener("file-removed", (e) => {
  const DETAILS = e.detail;
  console.log("[remove] file-removed:", DETAILS);

  let store = {};
  try {
    store = JSON.parse(localStorage.getItem(storageKey)) || {};
  } catch {
    store = {};
  }

  if (store[pathKey] && Array.isArray(store[pathKey])) {
    store[pathKey] = normalizeStoredArray(store[pathKey]);
    const idx = findIndexInArray(store[pathKey], DETAILS);
    if (idx >= 0) {
      // antes de eliminar, emitimos el evento con uuid + size
      const removedFile = store[pathKey][idx];
      document.dispatchEvent(new CustomEvent("delete-draft", {
        detail: {
          uuid: removedFile?.uuid,
          size: removedFile?.size
        }
      }));

      store[pathKey].splice(idx, 1);
      console.log("[remove] Eliminado en √≠ndice", idx);
    }

    if (store[pathKey].length === 0) delete store[pathKey];
    if (Object.keys(store).length === 0) {
      localStorage.removeItem(storageKey);
    } else {
      localStorage.setItem(storageKey, JSON.stringify(store));
    }

    updateHiddenInput(store[pathKey] || []);
  }
});


    }, 100);
  }).catch(err => console.error("‚ùå Error Uploadcare:", err));
</script>


<!-- ‚úÖ Image size + storage validator (fixed paths) -->
<script>
  function getCache(key, path) {
    try {
      const data = JSON.parse(localStorage.getItem(key));
      return path.split('.').reduce((acc, part) => acc?.[part], data);
    } catch {
      return undefined;
    }
  }

  const seenDrafts = new Set();

  const imageValidator9 = (fileEntry) => {
    const MAX_SIZE_MB = 1;
    const MAX_SIZE_BYTES = MAX_SIZE_MB * 1024 * 1024;
    const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];
    const DENIED_TYPES = ['image/svg+xml', 'image/gif'];

    const STORAGE_CAPACITY = getCache('offices', 'club.storage_bites');
    const STORAGE_USED     = getCache('offices', 'club.storage_used_bites'); // <-- ruta correcta

    // Tipo
    if (!fileEntry.mimeType || DENIED_TYPES.includes(fileEntry.mimeType)) {
      return { message: "No se aceptan SVG ni GIF. Solo JPG, PNG, WEBP o AVIF", code: "INVALID_TYPE" };
    }
    if (!ALLOWED_TYPES.includes(fileEntry.mimeType)) {
      return { message: "Solo se permiten im√°genes JPG, PNG, WEBP o AVIF", code: "INVALID_TYPE" };
    }

    // Tama√±o individual
    if (fileEntry.size > MAX_SIZE_BYTES) {
      const actualSizeMB = (fileEntry.size / (1024 * 1024)).toFixed(2);
      return { message: `Tama√±o m√°ximo: ${MAX_SIZE_MB}MB (subes: ${actualSizeMB}MB)`, code: "SIZE_EXCEEDED" };
    }

    // newTotal para evento y validaci√≥n
    const newTotal = (typeof STORAGE_USED === "number") ? (STORAGE_USED + fileEntry.size) : undefined;

    // Validaci√≥n de capacidad (solo si hay ambos n√∫meros)
    if (typeof STORAGE_CAPACITY === "number" && typeof STORAGE_USED === "number") {
      if (newTotal > STORAGE_CAPACITY) {
        return {
          message: `Almacenamiento insuficiente (usado: ${(STORAGE_USED/1024/1024).toFixed(2)}MB / capacidad: ${(STORAGE_CAPACITY/1024/1024).toFixed(2)}MB)`,
          code: "STORAGE_INSUFFICIENT"
        };
      }
    }

    // Evento (una vez por UUID)
    if (fileEntry.uuid && !seenDrafts.has(fileEntry.uuid)) {
      seenDrafts.add(fileEntry.uuid);
      document.dispatchEvent(new CustomEvent("new-draft", {
        detail: { uuid: fileEntry.uuid, total: newTotal }
      }));
    }

    return null;
  };

  document.addEventListener('uploadcare-ready', () => {
    customElements.whenDefined('uc-config').then(() => {
      const config = document.querySelector('uc-config[ctx-name="kits-details.paints"]');
      if (config) config.fileValidators = [imageValidator9];
    });
  });
</script>


<!-- ‚è´ new_draft -->
<script>
  document.addEventListener("new-draft", (e) => {
    const { uuid, total } = e.detail || {};
    if (!uuid) return;

    const apiURL = `/new_draft?uuid=${uuid}&total=${total ?? ""}`;
    const authToken = localStorage.getItem("AuthToken");
    if (!authToken) return;

    // Actualiza offices.club.storage_used_bites solo si total es n√∫mero
    try {
      if (typeof total === "number") {
        const offices = JSON.parse(localStorage.getItem("offices")) || {};
        if (!offices.club) offices.club = {};
        offices.club.storage_used_bites = total; // <-- ruta correcta
        localStorage.setItem("offices", JSON.stringify(offices));
      }
    } catch (err) {
      console.error("Error actualizando storage_used_bites:", err);
    }

    xano.setAuthToken(authToken);
    xano.post(apiURL).catch(err => console.error("Error /new_draft:", err));
  });
</script>

<!-- ‚è¨ delete_draft -->
<script>
  function getCache(key, path) {
    try {
      const data = JSON.parse(localStorage.getItem(key));
      return path.split('.').reduce((acc, part) => acc?.[part], data);
    } catch {
      return undefined;
    }
  }

  document.addEventListener("delete-draft", (e) => {
    const { uuid, size } = e.detail || {};
    if (!uuid || typeof size !== "number") return;

    const CURRENT = getCache('offices', 'club.storage_used_bites') || 0;
    const SUBSTRACTION = Math.max(0, CURRENT - size); // nunca negativo

    const apiURL = `/delete_draft?uuid=${uuid}&total=${SUBSTRACTION}`;
    const authToken = localStorage.getItem("AuthToken");
    if (!authToken) return;

    // Actualiza offices.club.storage_used_bites
    try {
      const offices = JSON.parse(localStorage.getItem("offices")) || {};
      if (!offices.club) offices.club = {};
      offices.club.storage_used_bites = SUBSTRACTION;
      localStorage.setItem("offices", JSON.stringify(offices));
      console.log("üóëÔ∏è Eliminado draft. Nuevo storage_used_bites =", SUBSTRACTION);
    } catch (err) {
      console.error("Error actualizando storage_used_bites:", err);
    }

    xano.setAuthToken(authToken);
    xano.post(apiURL).catch(err => console.error("Error /delete_draft:", err));
  });
</script>



<!-- üêû Uploadcare components -->
<script>
(function () {
  'use strict';

  // Config
  const MAX_RETRIES = 12;
  const RETRY_DELAY = 500;
  const CLICK_DELAY = 10; // delay configurable antes de hacer click en uc-drop-area
  const ACTIVITY_CLOSE_REMOVE_TIMEOUT = 10000; // ms: desconectar observer si no aparece en este tiempo

  function findNearestWithin(root, selector) {
    const candidates = Array.from(root.querySelectorAll(selector));
    if (!candidates.length) return null;
    return candidates[0];
  }

  function safeClick(el) {
    if (!el) return false;
    try { el.click(); return true; } catch (_) {
      try { el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true })); } catch(e){}
      try { el.dispatchEvent(new MouseEvent('mouseup',   { bubbles: true, cancelable: true })); } catch(e){}
      try { el.dispatchEvent(new MouseEvent('click',     { bubbles: true, cancelable: true })); return true; } catch (e) {
        return false;
      }
    }
  }

  // REMOVER el bot√≥n close dentro de uc-activity-header dentro de uc-upload-list[activity="upload-list"][mode="list"][active]
  // de forma robusta: intento inmediato + MutationObserver (desconecta luego).
  function removeActivityCloseButtonsRobust(uploaderEl) {
    if (!uploaderEl) return;
    const selector = 'uc-upload-list[activity="upload-list"][mode="list"][active] uc-activity-header > button.uc-mini-btn.uc-close-btn';

    function tryRemove() {
      const btns = Array.from(uploaderEl.querySelectorAll(selector));
      if (!btns.length) return false;
      btns.forEach(b => {
        try { b.remove(); } catch (e) { b.style.display = 'none'; b.setAttribute('aria-hidden','true'); }
      });
      return true;
    }

    // intento inmediato
    if (tryRemove()) return;

    // si no est√° a√∫n, observamos por si se inserta din√°micamente
    const mo = new MutationObserver((mutations, obs) => {
      if (tryRemove()) obs.disconnect();
    });
    mo.observe(uploaderEl, { childList: true, subtree: true });

    // desconectar por seguridad tras un timeout
    setTimeout(() => {
      try { mo.disconnect(); } catch (e) {}
    }, ACTIVITY_CLOSE_REMOVE_TIMEOUT);
  }

  async function processUploader(uploaderEl, idx) {
    if (!uploaderEl || uploaderEl.__processed) return { success: false, reason: 'already' };
    let attempt = 0;

    // arrancar observer inmediato para eliminaci√≥n robusta (no esperar a detecciones m√°s abajo)
    removeActivityCloseButtonsRobust(uploaderEl);

    while (attempt <= MAX_RETRIES) {
      attempt++;
      try {
        const uploadButton = uploaderEl.querySelector('[upload-button]');
        const doneButton   = uploaderEl.querySelector('button.uc-done-btn.uc-primary-btn');
        const toolbar = uploaderEl.querySelector('.uc-toolbar');

        const uploaderTab = findNearestWithin(uploaderEl, '[uploader-tab]');
        const buttonTab   = findNearestWithin(uploaderEl, '[button-tab]');
        const dropArea    = findNearestWithin(uploaderEl, 'uc-drop-area[clickable], uc-drop-area[initflow], uc-drop-area');

        const missing = [];
        if (!uploadButton) missing.push('upload-button');
        if (!uploaderTab)    missing.push('uploader-tab');
        if (!dropArea)       missing.push('uc-drop-area');

        if (missing.length) {
          if (attempt <= MAX_RETRIES) {
            await new Promise(r => setTimeout(r, RETRY_DELAY));
            continue;
          } else {
            return { success: false, reason: 'missing', missing };
          }
        }

        // 1) Eliminar botones dentro de .uc-toolbar: close mini-btn y cancel/secondary (Limpiar)
        if (toolbar) {
          try {
            const closeBtns = Array.from(toolbar.querySelectorAll('button.uc-mini-btn.uc-close-btn'));
            closeBtns.forEach(b => {
              try { b.remove(); } catch (e) { b.style.display = 'none'; b.setAttribute('aria-hidden','true'); }
            });
            const cancelBtns = Array.from(toolbar.querySelectorAll('button.uc-cancel-btn.uc-secondary-btn'));
            cancelBtns.forEach(b => {
              try { b.remove(); } catch (e) { b.style.display = 'none'; b.setAttribute('aria-hidden','true'); }
            });
          } catch (e) {
            // silent
          }
        }

        // 2) upload-button handler: uploader-tab -> wait -> drop-area (CLICK_DELAY configurable)
        const uploadHandler = (ev) => {
          try { ev?.stopImmediatePropagation?.(); ev?.preventDefault?.(); } catch(e){}
          try {
            if (uploaderTab) safeClick(uploaderTab);
            setTimeout(() => { safeClick(dropArea); }, CLICK_DELAY);
          } catch (err) {
            // silent
          }
        };
        if (uploadButton && !uploadButton.__uploader_hooked) {
          uploadButton.addEventListener('click', uploadHandler, { capture: true });
          uploadButton.__uploader_hooked = true;
        }

        // 3) DONE button: anular comportamiento nativo y en su lugar hacer CLICK en [button-tab] (solo eso)
        if (doneButton) {
          if (!doneButton.__uploader_hijacked) {
            doneButton.__uploader_hijacked = true;
            doneButton.addEventListener('click', (ev) => {
              try { ev.preventDefault?.(); ev.stopImmediatePropagation?.(); } catch(e){}
              let targetButtonTab = findNearestWithin(uploaderEl, '[button-tab]');
              if (!targetButtonTab) targetButtonTab = uploaderEl.querySelector('[button-tab]');
              if (targetButtonTab) {
                try { targetButtonTab.click(); } catch (err) {
                  try {
                    targetButtonTab.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true }));
                    targetButtonTab.dispatchEvent(new MouseEvent('mouseup',   { bubbles: true, cancelable: true }));
                    targetButtonTab.dispatchEvent(new MouseEvent('click',     { bubbles: true, cancelable: true }));
                  } catch (err2) { /* silent */ }
                }
              }
            }, { capture: true });
          }
        }

        // 4) [close] attribute elements: al click solo hacer click en [button-tab] (sin m√°s)
        const closeAttrEls = Array.from(uploaderEl.querySelectorAll('[close]'));
        closeAttrEls.forEach(cl => {
          if (cl.__close_hooked) return;
          cl.__close_hooked = true;
          cl.addEventListener('click', (ev) => {
            try { ev.preventDefault?.(); ev.stopImmediatePropagation?.(); } catch(e){}
            let targetButtonTab = findNearestWithin(uploaderEl, '[button-tab]');
            if (!targetButtonTab) targetButtonTab = uploaderEl.querySelector('[button-tab]');
            if (targetButtonTab) {
              try { targetButtonTab.click(); } catch (err) {
                try {
                  targetButtonTab.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true }));
                  targetButtonTab.dispatchEvent(new MouseEvent('mouseup',   { bubbles: true, cancelable: true }));
                  targetButtonTab.dispatchEvent(new MouseEvent('click',     { bubbles: true, cancelable: true }));
                } catch (err2) { /* silent */ }
              }
            }
          }, { capture: true });
        });

        // 5) button-tab handler (conservar comportamiento para clicks del usuario)
        const allButtonTabs = Array.from(uploaderEl.querySelectorAll('[button-tab]'));
        allButtonTabs.forEach(bt => {
          if (bt.__uploader_button_tab_hooked) return;
          bt.addEventListener('click', (ev) => {
            if (!ev.isTrusted) {
              return;
            }
            try { ev.preventDefault?.(); ev.stopImmediatePropagation?.(); } catch(e){}
            safeClick(dropArea);
            setTimeout(() => { safeClick(uploaderTab); }, CLICK_DELAY);
          }, { capture: true });
          bt.__uploader_button_tab_hooked = true;
        });

        // 6) Nuevo: permitir native Cancel dentro de .uc-content, luego IMMEDIATAMENTE click en [button-tab]
        try {
          const contentCancelBtn = uploaderEl.querySelector('.uc-content button.uc-secondary-btn');
          if (contentCancelBtn && !contentCancelBtn.__content_cancel_hooked) {
            contentCancelBtn.__content_cancel_hooked = true;
            contentCancelBtn.addEventListener('click', (ev) => {
              const targetButtonTab = findNearestWithin(uploaderEl, '[button-tab]') || uploaderEl.querySelector('[button-tab]');
              if (targetButtonTab) {
                setTimeout(() => {
                  try { targetButtonTab.click(); } catch (err) {
                    try {
                      targetButtonTab.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true }));
                      targetButtonTab.dispatchEvent(new MouseEvent('mouseup',   { bubbles: true, cancelable: true }));
                      targetButtonTab.dispatchEvent(new MouseEvent('click',     { bubbles: true, cancelable: true }));
                    } catch (err2) { /* silent */ }
                  }
                }, 0);
              }
            }, { capture: false });
          }
        } catch (e) {
          // silent
        }

        // asegurar eliminaci√≥n final si algo qued√≥ (intento extra)
        removeActivityCloseButtonsRobust(uploaderEl);

        uploaderEl.__processed = true;
        return { success: true };
      } catch (err) {
        if (attempt <= MAX_RETRIES) { await new Promise(r => setTimeout(r, RETRY_DELAY)); continue; }
        return { success: false, reason: 'exception', error: String(err) };
      }
    }
    return { success: false, reason: 'exhausted' };
  }

  function startProcessing() {
    const uploaders = Array.from(document.querySelectorAll('div[uploader]'));
    const total = uploaders.length;

    // arrancar observer/removal en todos los uploaders detectados inmediatamente
    uploaders.forEach((u) => removeActivityCloseButtonsRobust(u));

    let processed = 0;
    let failed = 0;
    (async () => {
      for (let i = 0; i < uploaders.length; i++) {
        const res = await processUploader(uploaders[i], i + 1);
        if (res.success) processed++; else failed++;
      }
      document.dispatchEvent(new CustomEvent('buttons-ready', { detail: { total, processed, failed } }));
      console.log("üêû Components");
    })();
  }

  document.addEventListener('uploadcare-ready', () => {
    if (customElements && customElements.whenDefined) {
      customElements.whenDefined('uc-config').then(() => {
        try {
          startProcessing();
        } catch (e) {
          document.dispatchEvent(new CustomEvent('buttons-ready', { detail: { total: 0, processed: 0, failed: 0, error: String(e) } }));
          console.log("üêû1 Components");
        }
      }).catch(() => {
        try { startProcessing(); } catch (e) {
          document.dispatchEvent(new CustomEvent('buttons-ready', { detail: { total: 0, processed: 0, failed: 0, error: String(e) } }));
          console.log("üêû2 Components");
        }
      });
    } else {
      try { startProcessing(); } catch (e) {
        document.dispatchEvent(new CustomEvent('buttons-ready', { detail: { total: 0, processed: 0, failed: 0, error: String(e) } }));
        console.log("üêû3 Components");
      }
    }
  });
})();
</script>