<style>
    [c-label].is-editing {
  outline: none;
  background-color: #f8f9fa; /* Un fondo muy sutil */
  border-bottom: 2px solid #007bff; /* Un subrayado que indica ediciÃ³n */
  cursor: text;
}
</style>

<!-- builder -->
<script>
(function(){
  'use strict';

  /* ---------- Utils ---------- */
  function safeJSONParse(str, fallback = null) {
    try { return JSON.parse(str); } catch { return fallback; }
  }
  function getNested(obj, path) {
    if (!obj || !path) return undefined;
    return path.split('.').reduce((acc, p) => (acc && acc[p] !== undefined) ? acc[p] : undefined, obj);
  }
  function showErrorModal(message) {
    if (typeof showToast === 'function') showToast(message, 'error');
    else if (typeof alert === 'function') alert(message);
    else console.error(message);
  }

  /* ---------- Estado ---------- */
  const COMPONENTS = new Map();

  /* ---------- ConstrucciÃ³n de todos los componentes ---------- */
  function buildAllComponents() {
    const components = document.querySelectorAll('[component-id]');
    components.forEach(component => {
      try { buildComponent(component); }
      catch (err) { console.error('BuildOptions: Error building component', component.getAttribute('component-id'), err); }
    });
    
    const dependentDisplayNodes = document.querySelectorAll('[display-depend]');
    dependentDisplayNodes.forEach(node => {
      node.style.display = 'none';
    });
    
    document.dispatchEvent(new Event('options-builder-ready'));
  }

  function buildComponent(component) {
    const componentId = component.getAttribute('component-id');
    const storageKey = component.getAttribute('storage-key') || null;
    const storagePath = component.getAttribute('storage-path') || '';
    const jsonPath = component.getAttribute('json-path') || '';
    const dependencies = String(component.getAttribute('dependencies') || '').toLowerCase() === 'true';
    const valueKey = component.getAttribute('value-key') || 'value';
    const labelKey = component.getAttribute('label-key') || 'label';
    const tagKey = component.getAttribute('tag-key') || 'tag';
    const idKey = component.getAttribute('id-key') || 'id';
    const clickKey = component.getAttribute('click-key') || null;
    const fClass = component.getAttribute('f-class') || '';
    const lClass = component.getAttribute('l-class') || '';
    const continueButtonId = component.getAttribute('continue-button-id') || null;
    const checkboxLimit = component.getAttribute('checkbox-limit') ? parseInt(component.getAttribute('checkbox-limit')) : null;
    const inputType = (component.getAttribute('input-type') || 'checkbox').toLowerCase();
    const groupComponentId = component.getAttribute('group-component-id') || componentId;
    const alwaysRequired = component.getAttribute('cf-required');

    if (!componentId || !jsonPath) {
      console.error(`BuildOptions: component "${componentId}": faltan atributos mÃ­nimos (component-id, json-path).`);
      return;
    }

    const groupEl = component.querySelector('[role="group"]');
    if (!groupEl) {
      console.error(`BuildOptions: component "${componentId}": falta elemento con role="group".`);
      return;
    }

    const fieldTemplate = component.querySelector('[c-field]');
    if (!fieldTemplate) {
      console.error(`BuildOptions: component "${componentId}": falta plantilla [c-field].`);
      return;
    }

    let optionsList = null;
    if (storageKey) {
      const raw = localStorage.getItem(storageKey);
      const storedObj = safeJSONParse(raw, null);
      if (storedObj) {
        if (storagePath) optionsList = getNested(storedObj, `${storagePath}.options`);
        else if (Array.isArray(storedObj)) optionsList = storedObj;
        else if (Array.isArray(storedObj.options)) optionsList = storedObj.options;
      } else {
        console.warn(`BuildOptions: component "${componentId}": no hay datos vÃ¡lidos en localStorage["${storageKey}"].`);
      }
    }

    if (!Array.isArray(optionsList) || optionsList.length === 0) {
      optionsList = [];
    }

    let hidden = component.querySelector(`input[type="hidden"][cf-json-path="${jsonPath}"]`);
    if (!hidden) {
      hidden = document.createElement('input');
      hidden.type = 'hidden';
      hidden.setAttribute('cf-json-path', jsonPath);
      hidden.name = jsonPath;
      component.appendChild(hidden);
    }

    if (alwaysRequired === 'true') {
      hidden.setAttribute('data-required', '');
      hidden.setAttribute('always-required', '');
    }

    if (continueButtonId) {
      hidden.setAttribute('continue-trigger', continueButtonId);
    }

    if (inputType === 'checkbox') hidden.value = hidden.value || '[]';
    else hidden.value = hidden.value || '{}';

    while (groupEl.firstChild) groupEl.removeChild(groupEl.firstChild);

    if (optionsList.length) {
      optionsList.forEach(item => {
        const clone = fieldTemplate.cloneNode(true);
        const tagEl = clone.querySelector('[c-tag]');
        const labelEl = clone.querySelector('[c-label]');
        const nativeInput = clone.querySelector('[native-button], input[type="checkbox"], input[type="radio"], input');

        const labelText = String(item[labelKey] ?? '');
        const tagText = String(item[tagKey] ?? '').trim();
        const valText = String(item[valueKey] ?? '');
        const idVal = idKey ? (item[idKey] !== undefined ? String(item[idKey]) : null) : null;
        const clickVal = clickKey ? (item[clickKey] !== undefined ? String(item[clickKey]) : null) : null;

        if (idVal) clone.setAttribute('data-id', idVal);
        clone.setAttribute('active', 'false');

        if (labelEl) labelEl.textContent = labelText;
        if (tagEl) {
          if (tagText) { tagEl.textContent = tagText; tagEl.style.display = ''; }
          else { tagEl.textContent = ''; tagEl.style.display = 'none'; }
        }

        if (nativeInput) {
          nativeInput.type = inputType;
          nativeInput.setAttribute('data-opt-value', valText);
          nativeInput.setAttribute('data-opt-label', labelText);
          if (idVal) nativeInput.setAttribute('data-opt-id', idVal);
          if (tagText) nativeInput.setAttribute('data-opt-tag', tagText);
          if (clickVal) nativeInput.setAttribute('data-opt-click', clickVal);
          if (inputType === 'radio') nativeInput.name = groupComponentId;
        } else {
          console.warn(`BuildOptions: component "${componentId}": clone c-field no contiene native-button ni input detectable.`);
        }

        if (clickVal) clone.setAttribute('cl', clickVal);
        groupEl.appendChild(clone);
      });
    }

    if (!groupEl._hasDelegate) {
      groupEl.addEventListener('change', (evt) => onGroupChange(evt, componentId));
      groupEl._hasDelegate = true;
    }

    // --- NUEVO: Listener de click para la funcionalidad "Otros" ---
    if (!groupEl._hasClickDelegate) {
        groupEl.addEventListener('click', (evt) => onGroupClick(evt, componentId));
        groupEl._hasClickDelegate = true;
    }

    COMPONENTS.set(componentId, {
      componentId, componentEl: component, storageKey, storagePath, jsonPath, dependencies,
      valueKey, labelKey, tagKey, idKey, clickKey, fClass, lClass, continueButtonId,
      checkboxLimit, inputType, groupEl, fieldTemplate, hiddenEl: hidden, alwaysRequired,
      currentValue: inputType === 'checkbox' ? [] : {}
    });

    syncUIFromHidden(componentId);
  }

  /* ---------- Sincronizar UI inicial desde hidden ---------- */
  function syncUIFromHidden(componentId) {
    const state = COMPONENTS.get(componentId);
    if (!state) return;
    const { hiddenEl, inputType, groupEl, fClass, lClass } = state;
    const raw = hiddenEl.value;
    if (raw === undefined || raw === null) return;
    const parsed = safeJSONParse(raw, null);

    groupEl.querySelectorAll('[c-field]').forEach(fe => {
      if (fClass) fe.classList.remove(fClass);
      fe.setAttribute('active', 'false');
      const lab = fe.querySelector('[c-label]');
      if (lab && lClass) lab.classList.remove(lClass);
      const inp = fe.querySelector('[native-button], input');
      if (inp) inp.checked = false;
    });

    if (inputType === 'checkbox' && Array.isArray(parsed)) {
      parsed.forEach(item => {
        groupEl.querySelectorAll('[native-button], input').forEach(inp => {
          if (String(inp.getAttribute('data-opt-value')) === String(item.value)) {
            inp.checked = true;
            const fe = inp.closest('[c-field]');
            if(fe) {
              if(fClass) fe.classList.add(fClass);
              fe.setAttribute('active', 'true');
              const lab = fe.querySelector('[c-label]');
              if (lab) {
                if(lClass) lab.classList.add(lClass);
                // --- MODIFICADO: Asegura que el label custom se cargue al inicio ---
                lab.textContent = item.label;
              }
            }
          }
        });
      });
      state.currentValue = parsed.slice();
    } else if (inputType === 'radio' && parsed && typeof parsed === 'object' && Object.keys(parsed).length) {
      groupEl.querySelectorAll('[native-button], input').forEach(inp => {
        if (String(inp.getAttribute('data-opt-value')) === String(parsed.value)) {
          inp.checked = true;
          const fe = inp.closest('[c-field]');
          if(fe) {
            if(fClass) fe.classList.add(fClass);
            fe.setAttribute('active', 'true');
            const lab = fe.querySelector('[c-label]');
            if (lab) {
              if (lClass) lab.classList.add(lClass);
              // --- MODIFICADO: Asegura que el label custom se cargue al inicio ---
              lab.textContent = parsed.label;
            }
          }
        }
      });
      state.currentValue = parsed;
    } else {
      state.currentValue = inputType === 'checkbox' ? [] : {};
    }
  }

  /* ---------- Cambio delegado en role=group ---------- */
  function onGroupChange(evt, componentId) {
    const input = evt.target;
    if (!input || !(input instanceof HTMLInputElement)) return;

    const state = COMPONENTS.get(componentId);
    if (!state) return;

    const { inputType, hiddenEl, checkboxLimit, fClass, lClass, groupEl } = state;
    const value = input.getAttribute('data-opt-value');
    const label = input.getAttribute('data-opt-label') || '';
    const id = input.getAttribute('data-opt-id') || null;
    const isChecked = input.checked;

    if (inputType === 'checkbox') {
      let current = safeJSONParse(hiddenEl.value, []);
      current = Array.isArray(current) ? current : [];

      const exists = current.some(it => String(it.value) === String(value));
      if (isChecked && !exists) {
        if (checkboxLimit && current.length >= checkboxLimit) {
          showErrorModal(`Selecciona mÃ¡ximo ${checkboxLimit} opciones.`);
          input.checked = false;
          return;
        }
        const entry = { value, label };
        if (id) entry.id = id;
        current.push(entry);
      } else if (!isChecked && exists) {
        current = current.filter(it => String(it.value) !== String(value));
        // --- MODIFICADO: Resetea el label de "Otros" al deseleccionar ---
        if (value === 'others') {
            const fieldEl = input.closest('[c-field]');
            const labelEl = fieldEl ? fieldEl.querySelector('[c-label]') : null;
            if (labelEl) {
                labelEl.textContent = label; // Resetea al label original
            }
        }
      }

      const fieldEl = input.closest('[c-field]');
      fieldEl && fClass && fieldEl.classList.toggle(fClass, isChecked);
      fieldEl && fieldEl.setAttribute('active', isChecked ? 'true' : 'false');
      const lab = fieldEl && fieldEl.querySelector('[c-label]');
      lab && lClass && lab.classList.toggle(lClass, isChecked);

      hiddenEl.value = JSON.stringify(current);
      state.currentValue = current.slice();

      emitOptionEvents('checkbox', state, input, { value, label, id, isChecked, currentValue: current });

    } else if (inputType === 'radio') {
      const entry = { value, label };
      if (id) entry.id = id;

      groupEl.querySelectorAll('[c-field]').forEach(fe => {
        fClass && fe.classList.remove(fClass);
        fe.setAttribute('active', 'false');
        const lab = fe.querySelector('[c-label]');
        lab && lClass && lab.classList.remove(lClass);
      });

      const fieldEl = input.closest('[c-field]');
      fieldEl && fClass && fieldEl.classList.add(fClass);
      fieldEl && fieldEl.setAttribute('active', 'true');
      const lab = fieldEl && fieldEl.querySelector('[c-label]');
      lab && lClass && lab.classList.add(lClass);

      hiddenEl.value = JSON.stringify(entry);
      state.currentValue = Object.assign({}, entry);

      emitOptionEvents('radio', state, input, { value, label, id, isChecked: true, currentValue: state.currentValue });
    }
  }

  // --- NUEVO: Handler para el evento click, gestiona la ediciÃ³n de "Otros" ---
  function onGroupClick(evt, componentId) {
    const fieldEl = evt.target.closest('[c-field]');
    if (!fieldEl) return;

    const nativeInput = fieldEl.querySelector('[native-button], input');
    if (!nativeInput || nativeInput.getAttribute('data-opt-value') !== 'others' || !nativeInput.checked) {
        return;
    }

    const labelEl = fieldEl.querySelector('[c-label]');
    if (labelEl && !labelEl.isContentEditable) {
        makeLabelEditable(labelEl, nativeInput, componentId);
    }
  }

  // --- NUEVO: Convierte un label en editable ---
  function makeLabelEditable(labelEl, nativeInput, componentId) {
    const originalLabel = nativeInput.getAttribute('data-opt-label');

    // Si el texto es el original, lo vaciamos para dar feedback de ediciÃ³n
    if (labelEl.textContent === originalLabel) {
        labelEl.textContent = '';
    }
    
    labelEl.contentEditable = true;
    labelEl.classList.add('is-editing'); // Para estilos CSS opcionales: [c-label].is-editing
    labelEl.focus();

    // Seleccionar todo el texto si ya hay algo escrito
    const selection = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(labelEl);
    selection.removeAllRanges();
    selection.addRange(range);

    const onBlur = () => {
        labelEl.contentEditable = false;
        labelEl.classList.remove('is-editing');
        let newText = labelEl.textContent.trim();

        if (newText === '') {
            newText = originalLabel;
            labelEl.textContent = newText;
        }
        
        updateHiddenStateLabel(componentId, newText);

        // Limpieza del listener
        labelEl.removeEventListener('blur', onBlur);
        labelEl.removeEventListener('keydown', onKeydown);
    };

    const onKeydown = (e) => {
        // Guardar con Enter, prevenir salto de lÃ­nea
        if (e.key === 'Enter') {
            e.preventDefault();
            labelEl.blur();
        }
    };
    
    labelEl.addEventListener('blur', onBlur);
    labelEl.addEventListener('keydown', onKeydown);
  }

  // --- NUEVO: Actualiza el label en el valor del input hidden ---
  function updateHiddenStateLabel(componentId, newLabel) {
    const state = COMPONENTS.get(componentId);
    if (!state) return;

    const { hiddenEl, inputType } = state;
    let current = safeJSONParse(hiddenEl.value, inputType === 'checkbox' ? [] : {});
    
    if (inputType === 'checkbox' && Array.isArray(current)) {
        const otherIndex = current.findIndex(item => item.value === 'others');
        if (otherIndex > -1) {
            current[otherIndex].label = newLabel;
        }
    } else if (inputType === 'radio' && current.value === 'others') {
        current.label = newLabel;
    }

    const newJsonValue = JSON.stringify(current);
    hiddenEl.value = newJsonValue;
    state.currentValue = current;
    
    // Dispara un evento para notificar que el valor (aunque sea solo el label) cambiÃ³
    document.dispatchEvent(new CustomEvent('option-value-updated', { detail: { componentId, value: newJsonValue } }));
  }

  /* ---------- Emitir eventos (compatibles con handlers) ---------- */
  function emitOptionEvents(type, state, input, payload) {
    const detail = {
      componentId: state.componentId, jsonPath: state.jsonPath, type,
      value: payload.value, label: payload.label, id: payload.id, isChecked: payload.isChecked,
      currentValue: payload.currentValue, alwaysRequired: state.alwaysRequired,
      dependencies: state.dependencies, continueButtonId: state.continueButtonId,
    };

    console.group(`ðŸ“¤ Emitiendo evento de opciÃ³n (${type})`);
    console.table(detail);
    console.groupEnd();

    document.dispatchEvent(new CustomEvent('option-change', { detail }));
    if (type === 'checkbox') {
      document.dispatchEvent(new CustomEvent('valid-change-checkbox', { detail }));
    } else if (type === 'radio') {
      document.dispatchEvent(new CustomEvent('valid-change-radio', { detail }));
    }
  }

  /* ---------- InicializaciÃ³n: escuchar data-ready ---------- */
  document.addEventListener('data-ready', buildAllComponents);

  // Exponer para debugging
  window.__OptionsBuilder = { COMPONENTS };

})();
</script>

<!-- checkbox -->
<script>
(function(){
Â  'use strict';

Â  function cleanSubComponents(container) {
Â  Â  if (!container || !(container instanceof Element)) return;
Â  Â  
Â  Â  Â  Â // 1. Limpieza de elementos del Color Picker
container.querySelectorAll('a[color-element-template]').forEach(el => {
Â  Â  console.debug('Simulating click on color picker element:', el);
Â  Â  el.click(); // Simula un clic para activar la lÃ³gica de eliminaciÃ³n
});

// 2. RestauraciÃ³n del botÃ³n de selecciÃ³n de color
const selectColorBtn = container.querySelector('[internal-input-select-color]');
if (selectColorBtn) {
Â  Â  selectColorBtn.style.borderColor = '';
Â  Â  selectColorBtn.style.color = '';
Â  Â  selectColorBtn.classList.remove('previewed');
}
Â  Â  
Â  Â  // 3. Limpieza de elementos del Uploader de Uploadcare
Â  Â  // Selector mÃ¡s especÃ­fico para el botÃ³n de eliminar dentro de cada item de archivo
Â  Â  container.querySelectorAll('uc-file-item .uc-remove-btn').forEach(button => {
Â  Â  Â  console.debug('Simulating click on Uploadcare remove button in container:', button);
Â  Â  Â  button.click();
Â  Â  });

Â  Â  // 4. Limpieza de campos contenteditable
Â  Â  container.querySelectorAll('[contenteditable="true"]').forEach(el => {
Â  Â  Â  console.debug('Cleaning contenteditable element in container:', el);
Â  Â  Â  el.innerHTML = '';
Â  Â  });
Â  Â  
Â  Â  // 5. Limpieza de inputs nativos y hidden
Â  Â  container.querySelectorAll('input, textarea, select').forEach(i => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  if (i instanceof HTMLInputElement && (i.type === 'checkbox' || i.type === 'radio')) {
Â  Â  Â  Â  Â  Â  Â  Â  i.checked = false;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  i.value = '';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (i.selectedIndex !== undefined) try { i.selectedIndex = -1; } catch(e){}
Â  Â  Â  Â  } catch(e) {}
Â  Â  });
Â  Â  
Â  Â  container.querySelectorAll('[component-id] input[type="hidden"][cf-json-path]').forEach(h => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const inputType = h.closest('[component-id]').getAttribute('input-type');
Â  Â  Â  Â  Â  Â  h.value = (inputType === 'checkbox') ? '[]' : (inputType === 'radio' ? '{}' : '');
Â  Â  Â  Â  } catch(e) {}
Â  Â  });

Â  Â  // 6. Limpieza de clases de selecciÃ³n para Checkboxes y Radios dentro del contenedor
Â  Â  const buttonComponents = container.querySelectorAll('[component-id][input-type="checkbox"], [component-id][input-type="radio"]');
Â  Â  buttonComponents.forEach(comp => {
Â  Â  Â  const fieldClass = comp.getAttribute('f-class');
Â  Â  Â  const labelClass = comp.getAttribute('l-class');
Â  Â  Â  
Â  Â  Â  if (fieldClass) {
Â  Â  Â  Â  comp.querySelectorAll(`.${fieldClass}`).forEach(el => el.classList.remove(fieldClass));
Â  Â  Â  }
Â  Â  Â  if (labelClass) {
Â  Â  Â  Â  comp.querySelectorAll(`.${labelClass}`).forEach(el => el.classList.remove(labelClass));
Â  Â  Â  }
Â  Â  });
Â  }

Â  document.addEventListener('valid-change-checkbox', (e) => {
Â  Â  try {
Â  Â  Â  const detail = e.detail || {};
Â  Â  Â  const componentId = detail.componentId;
Â  Â  Â  const dependencies = !!detail.dependencies;
Â  Â  Â  const currentValue = Array.isArray(detail.currentValue) ? detail.currentValue : [];
Â  Â  Â  const currentValues = currentValue.map(it => String(it.value));
Â  Â  Â  const jsonPath = detail.jsonPath || null;
Â  Â  Â  const continueButtonId = detail.continueButtonId || null;

Â  Â  Â  if (!componentId) return;

Â  Â  Â  const component = document.querySelector(`[component-id="${componentId}"]`);
Â  Â  Â  if (!component) return;
Â  Â  Â  const scope = component.closest('[cf-form-submit]') || document;

Â  Â  Â  // Actualiza el hidden input principal y dispara su evento
Â  Â  Â  if (jsonPath) {
Â  Â  Â  Â  let compHidden = component.querySelector(`input[cf-json-path="${jsonPath}"]`);
Â  Â  Â  Â  if (!compHidden) compHidden = component.querySelector(`input[type="hidden"][cf-json-path]`);
Â  Â  Â  Â  if (compHidden) {
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  compHidden.value = JSON.stringify(currentValue);
Â  Â  Â  Â  Â  Â  compHidden.dispatchEvent(new Event('change', { bubbles: true }));
Â  Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  Â  console.error('CBX-2: error setting hidden value', err);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  if (!dependencies) {
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  const nodesToHandle = scope.querySelectorAll(`[display-depend="${componentId}"], [required-depend="${componentId}"]`);

Â  Â  Â  nodesToHandle.forEach(node => {
Â  Â  Â  Â  const match = node.getAttribute('match');
Â  Â  Â  Â  const isDisplayDepend = node.hasAttribute('display-depend');
Â  Â  Â  Â  const isRequiredDepend = node.hasAttribute('required-depend');
Â  Â  Â  Â  const shouldActivate = match ? currentValues.includes(String(match).trim()) : (currentValues.length > 0);

Â  Â  Â  Â  if (isDisplayDepend) {
Â  Â  Â  Â  Â  const isCurrentlyVisible = node.style.display !== 'none';
Â  Â  Â  Â  Â  if (shouldActivate && !isCurrentlyVisible) {
Â  Â  Â  Â  Â  Â  node.style.display = '';

Â  Â  Â  Â  Â  Â  // La clave: retrasar la limpieza de sub-dependientes
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  node.querySelectorAll('[sub-dep="true"]').forEach(subDep => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  subDep.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cleanSubComponents(subDep);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  subDep.querySelectorAll('[data-required]').forEach(el => el.removeAttribute('data-required'));
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }, 50);

Â  Â  Â  Â  Â  } else if (!shouldActivate && isCurrentlyVisible) {
Â  Â  Â  Â  Â  Â  node.style.display = 'none';
Â  Â  Â  Â  Â  Â  cleanSubComponents(node);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (isRequiredDepend) {
Â  Â  Â  Â  Â  const candidates = Array.from(node.querySelectorAll('[cf-json-path]')).filter(el => el && el.matches('input,textarea,select'));
Â  Â  Â  Â  Â  const isCurrentlyRequired = candidates.length > 0 && candidates[0].hasAttribute('data-required');

Â  Â  Â  Â  Â  if (shouldActivate && !isCurrentlyRequired) {
Â  Â  Â  Â  Â  Â  candidates.forEach(h => h.setAttribute('data-required', ''));
Â  Â  Â  Â  Â  } else if (!shouldActivate && isCurrentlyRequired) {
Â  Â  Â  Â  Â  Â  candidates.forEach(h => {
Â  Â  Â  Â  Â  Â  Â  // â­ MODIFICACIÃ“N CLAVE: Comprobar la existencia del atributo, no su valor.
Â  Â  Â  Â  Â  Â  Â  const alwaysReq = h.hasAttribute('always-required');
Â  Â  Â  Â  Â  Â  Â  if (!alwaysReq) {
Â  Â  Â  Â  Â  Â  Â  Â  h.removeAttribute('data-required');
Â  Â  Â  Â  Â  Â  Â  Â  cleanSubComponents(node);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  // === Validaciones de dependencia unificadas (con delay) ===
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  const allDependentNodes = scope.querySelectorAll('[validate-parent], [validate-input]');

Â  Â  Â  Â  allDependentNodes.forEach(node => {
Â  Â  Â  Â  Â  const validateParentID = node.getAttribute('validate-parent');
Â  Â  Â  Â  Â  const validateInputID = node.getAttribute('validate-input');
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  let parentIsVisible = true;
Â  Â  Â  Â  Â  if (validateParentID) {
Â  Â  Â  Â  Â  Â  const parentNode = scope.querySelector(`[parent-id="${validateParentID}"]`);
Â  Â  Â  Â  Â  Â  parentIsVisible = parentNode && parentNode.style.display !== 'none';
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  let inputIsActive = true;
Â  Â  Â  Â  Â  if (validateInputID) {
Â  Â  Â  Â  Â  Â  const cField = scope.querySelector(`[c-field][data-id="${validateInputID}"]`);
Â  Â  Â  Â  Â  Â  inputIsActive = cField && cField.getAttribute('active') === 'true';
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  const shouldActivate = parentIsVisible && inputIsActive;
Â  Â  Â  Â  Â  const inputs = node.querySelectorAll('input, textarea, select');
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  if (shouldActivate) {
Â  Â  Â  Â  Â  Â  node.style.display = '';
Â  Â  Â  Â  Â  Â  inputs.forEach(input => input.setAttribute('data-required', ''));
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  node.style.display = 'none';
Â  Â  Â  Â  Â  Â  inputs.forEach(input => input.removeAttribute('data-required'));
Â  Â  Â  Â  Â  Â  cleanSubComponents(node);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  }, 50);

Â  Â  Â  if (continueButtonId) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  document.dispatchEvent(new CustomEvent('trigger-validate-continue', { detail: { continueButtonId } }));
Â  Â  Â  Â  } catch(e){}
Â  Â  Â  }

Â  Â  } catch (err) {
Â  Â  Â  console.error('CBX-2 handler error', err);
Â  Â  }
Â  });
})();
</script>

<!-- radio -->

<script>
(function(){
Â  'use strict';

Â  function cleanSubComponents(container) {
Â  Â  if (!container || !(container instanceof Element)) return;
Â  Â  
Â  Â  // 1. Limpieza de elementos del Color Picker
Â  Â  container.querySelectorAll('a[color-element-template]').forEach(el => {
Â  Â  Â  console.debug('Simulating click on color picker element:', el);
Â  Â  Â  el.click(); // Simula un clic para activar la lÃ³gica de eliminaciÃ³n
Â  Â  });

Â  Â  // 2. RestauraciÃ³n del botÃ³n de selecciÃ³n de color
Â  Â  const selectColorBtn = container.querySelector('[internal-input-select-color]');
Â  Â  if (selectColorBtn) {
Â  Â  Â  selectColorBtn.style.borderColor = '';
Â  Â  Â  selectColorBtn.style.color = '';
Â  Â  Â  selectColorBtn.classList.remove('previewed');
Â  Â  }
Â  Â  // 3. Limpieza de elementos del Uploader de Uploadcare
Â  Â  // Selector mÃ¡s especÃ­fico para el botÃ³n de eliminar dentro de cada item de archivo
Â  Â  container.querySelectorAll('uc-file-item .uc-remove-btn').forEach(button => {
Â  Â  Â  console.debug('Simulating click on Uploadcare remove button in container:', button);
Â  Â  Â  button.click();
Â  Â  });

Â  Â  // 4. Limpieza de campos contenteditable
Â  Â  container.querySelectorAll('[contenteditable="true"]').forEach(el => {
Â  Â  Â  console.debug('Cleaning contenteditable element in container:', el);
Â  Â  Â  el.innerHTML = '';
Â  Â  });
Â  Â  
Â  Â  // 5. Limpieza de inputs nativos y hidden
Â  Â  container.querySelectorAll('input, textarea, select').forEach(i => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  if (i instanceof HTMLInputElement && (i.type === 'checkbox' || i.type === 'radio')) {
Â  Â  Â  Â  Â  Â  Â  Â  i.checked = false;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  i.value = '';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (i.selectedIndex !== undefined) try { i.selectedIndex = -1; } catch(e){}
Â  Â  Â  Â  } catch(e) {}
Â  Â  });

Â  Â  container.querySelectorAll('[component-id] input[type="hidden"][cf-json-path]').forEach(h => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const inputType = h.closest('[component-id]').getAttribute('input-type');
Â  Â  Â  Â  Â  Â  h.value = (inputType === 'checkbox') ? '[]' : (inputType === 'radio' ? '{}' : '');
Â  Â  Â  Â  } catch(e) {}
Â  Â  });

Â  Â  // 6. Limpieza de clases de selecciÃ³n para Radios y Checkboxes dentro del contenedor
Â  Â  const buttonComponents = container.querySelectorAll('[component-id][input-type="checkbox"], [component-id][input-type="radio"]');
Â  Â  buttonComponents.forEach(comp => {
Â  Â  Â  const fieldClass = comp.getAttribute('f-class');
Â  Â  Â  const labelClass = comp.getAttribute('l-class');
Â  Â  Â  
Â  Â  Â  if (fieldClass) {
Â  Â  Â  Â  comp.querySelectorAll(`.${fieldClass}`).forEach(el => el.classList.remove(fieldClass));
Â  Â  Â  }
Â  Â  Â  if (labelClass) {
Â  Â  Â  Â  comp.querySelectorAll(`.${labelClass}`).forEach(el => el.classList.remove(labelClass));
Â  Â  Â  }
Â  Â  });
Â  }

Â  document.addEventListener('valid-change-radio', (e) => {
Â  Â  try {
Â  Â  Â  const detail = e.detail || {};
Â  Â  Â  const componentId = detail.componentId;
Â  Â  Â  const dependencies = !!detail.dependencies;
Â  Â  Â  const currentValue = detail.currentValue || null;
Â  Â  Â  const jsonPath = detail.jsonPath || null;
Â  Â  Â  const continueButtonId = detail.continueButtonId || null;

Â  Â  Â  if (!componentId) return;
Â  Â  Â  
Â  Â  Â  const component = document.querySelector(`[component-id="${componentId}"]`);
Â  Â  Â  if (!component) return;
Â  Â  Â  const scope = component.closest('[cf-form-submit]') || document;
Â  Â  Â  
Â  Â  Â  // Actualiza el hidden input principal y dispara su evento
Â  Â  Â  if (jsonPath) {
Â  Â  Â  Â  let compHidden = component.querySelector(`input[cf-json-path="${jsonPath}"]`);
Â  Â  Â  Â  if (!compHidden) compHidden = component.querySelector(`input[type="hidden"][cf-json-path]`);
Â  Â  Â  Â  if (compHidden) {
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  compHidden.value = JSON.stringify(currentValue);
Â  Â  Â  Â  Â  Â  compHidden.dispatchEvent(new Event('change', { bubbles: true }));
Â  Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  Â  console.error('RAD-2: error setting hidden value', err);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  if (!dependencies) {
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  const nodesToHandle = scope.querySelectorAll(`[display-depend="${componentId}"], [required-depend="${componentId}"]`);

Â  Â  Â  nodesToHandle.forEach(node => {
Â  Â  Â  Â  const match = node.getAttribute('match');
Â  Â  Â  Â  const isDisplayDepend = node.hasAttribute('display-depend');
Â  Â  Â  Â  const isRequiredDepend = node.hasAttribute('required-depend');
Â  Â  Â  Â  const currentVal = currentValue ? String(currentValue.value) : null;
Â  Â  Â  Â  const shouldActivate = match ? currentVal === String(match).trim() : (currentVal !== null);

Â  Â  Â  Â  if (isDisplayDepend) {
Â  Â  Â  Â  Â  const isCurrentlyVisible = node.style.display !== 'none';
Â  Â  Â  Â  Â  if (shouldActivate && !isCurrentlyVisible) {
Â  Â  Â  Â  Â  Â  node.style.display = '';

Â  Â  Â  Â  Â  Â  // La clave: retrasar la limpieza de sub-dependientes
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  node.querySelectorAll('[sub-dep="true"]').forEach(subDep => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  subDep.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cleanSubComponents(subDep);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  subDep.querySelectorAll('[data-required]').forEach(el => el.removeAttribute('data-required'));
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }, 50);
Â  Â  Â  Â  Â  } else if (!shouldActivate && isCurrentlyVisible) {
Â  Â  Â  Â  Â  Â  node.style.display = 'none';
Â  Â  Â  Â  Â  Â  cleanSubComponents(node);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (isRequiredDepend) {
Â  Â  Â  Â  Â  const candidates = Array.from(node.querySelectorAll('[cf-json-path]')).filter(el => el && el.matches('input,textarea,select'));
Â  Â  Â  Â  Â  const isCurrentlyRequired = candidates.length > 0 && candidates[0].hasAttribute('data-required');

Â  Â  Â  Â  Â  if (shouldActivate && !isCurrentlyRequired) {
Â  Â  Â  Â  Â  Â  candidates.forEach(h => h.setAttribute('data-required', ''));
Â  Â  Â  Â  Â  } else if (!shouldActivate && isCurrentlyRequired) {
Â  Â  Â  Â  Â  Â  candidates.forEach(h => {
Â  Â  Â  Â  Â  Â  Â  // â­ MODIFICACIÃ“N CLAVE: Comprobar la existencia del atributo, no su valor.
Â  Â  Â  Â  Â  Â  Â  const alwaysReq = h.hasAttribute('always-required');
Â  Â  Â  Â  Â  Â  Â  if (!alwaysReq) {
Â  Â  Â  Â  Â  Â  Â  Â  h.removeAttribute('data-required');
Â  Â  Â  Â  Â  Â  Â  Â  cleanSubComponents(node);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  // === Validaciones de dependencia unificadas (con delay) ===
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  const allDependentNodes = scope.querySelectorAll('[validate-parent], [validate-input]');

Â  Â  Â  Â  allDependentNodes.forEach(node => {
Â  Â  Â  Â  Â  const validateParentID = node.getAttribute('validate-parent');
Â  Â  Â  Â  Â  const validateInputID = node.getAttribute('validate-input');
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  let parentIsVisible = true;
Â  Â  Â  Â  Â  if (validateParentID) {
Â  Â  Â  Â  Â  Â  const parentNode = scope.querySelector(`[parent-id="${validateParentID}"]`);
Â  Â  Â  Â  Â  Â  parentIsVisible = parentNode && parentNode.style.display !== 'none';
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  let inputIsActive = true;
Â  Â  Â  Â  Â  if (validateInputID) {
Â  Â  Â  Â  Â  Â  const cField = scope.querySelector(`[c-field][data-id="${validateInputID}"]`);
Â  Â  Â  Â  Â  Â  inputIsActive = cField && cField.getAttribute('active') === 'true';
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  const shouldActivate = parentIsVisible && inputIsActive;
Â  Â  Â  Â  Â  const inputs = node.querySelectorAll('input, textarea, select');
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  if (shouldActivate) {
Â  Â  Â  Â  Â  Â  node.style.display = '';
Â  Â  Â  Â  Â  Â  inputs.forEach(input => input.setAttribute('data-required', ''));
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  node.style.display = 'none';
Â  Â  Â  Â  Â  Â  inputs.forEach(input => input.removeAttribute('data-required'));
Â  Â  Â  Â  Â  Â  cleanSubComponents(node);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  }, 50);

Â  Â  Â  if (continueButtonId) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  document.dispatchEvent(new CustomEvent('trigger-validate-continue', { detail: { continueButtonId } }));
Â  Â  Â  Â  } catch(e){}
Â  Â  Â  }

Â  Â  } catch (err) {
Â  Â  Â  console.error('RAD-2 handler error', err);
Â  Â  }
Â  });
})();
</script>


<!-- continue -->
<script>
(function(){
Â  'use strict';

Â  // --- ConfiguraciÃ³n ---
Â  const VALIDATION_DELAY = 120; // â±ï¸ Ajusta el delay en ms

Â  // --- MÃ³dulo de validaciÃ³n ---
Â  const ValidationModule = {
Â  Â  isFieldEmpty: function(field) {
Â  Â  Â  const rawValue = field.value;
Â  Â  Â  
Â  Â  Â  if (rawValue === '[]' || rawValue === '{}') return true;
Â  Â  Â  
Â  Â  Â  try {
Â  Â  Â  Â  const parsed = JSON.parse(rawValue);
Â  Â  Â  Â  if (Array.isArray(parsed) && parsed.length === 0) return true;
Â  Â  Â  Â  if (typeof parsed === 'object' && Object.keys(parsed).length === 0) return true;
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  return !rawValue || rawValue.trim() === '';
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  return false;
Â  Â  }
Â  };

Â  // --- Scroll hacia el botÃ³n ---
Â  function scrollToButton(button) {
Â  Â  if (!button) return;
Â  Â  const rect = button.getBoundingClientRect();
Â  Â  const isVisible = (rect.top >= 0 && rect.bottom <= window.innerHeight);
Â  Â  
Â  Â  // â­ Scroll suave solo si el botÃ³n no estÃ¡ visible en el viewport
Â  Â  if (!isVisible) {
Â  Â  Â  button.scrollIntoView({
Â  Â  Â  Â  behavior: 'smooth',
Â  Â  Â  Â  block: 'center'
Â  Â  Â  });
Â  Â  }
Â  }

Â  // --- Validar y actualizar botÃ³n ---
Â  function validateContinueButton(buttonId) {
Â  Â  if (!buttonId) return;

Â  Â  const requiredFields = document.querySelectorAll(
Â  Â  Â  `[continue-trigger="${buttonId}"][data-required]`
Â  Â  );
Â  Â  
Â  Â  let allFilled = true;
Â  Â  const validatedInputs = [];
Â  Â  
Â  Â  requiredFields.forEach(field => {
Â  Â  Â  const isFilled = !ValidationModule.isFieldEmpty(field);
Â  Â  Â  if (!isFilled) {
Â  Â  Â  Â  allFilled = false;
Â  Â  Â  }
Â  Â  Â  validatedInputs.push({
Â  Â  Â  Â  inputId: field.id || field.getAttribute('cf-json-path') || 'Sin ID',
Â  Â  Â  Â  filled: isFilled
Â  Â  Â  });
Â  Â  });
Â  Â  
Â  Â  console.log(
Â  Â  Â  `ðŸ“Š ValidaciÃ³n del botÃ³n "${buttonId}"`, 
Â  Â  Â  {
Â  Â  Â  Â  requiredInputsCount: requiredFields.length,
Â  Â  Â  Â  validatedInputs: validatedInputs,
Â  Â  Â  Â  allRequiredFilled: allFilled
Â  Â  Â  }
Â  Â  );
Â  Â  
Â  Â  const continueButton = document.getElementById(buttonId);
Â  Â  if (!continueButton) return;
Â  Â  
Â  Â  continueButton.classList.toggle('inutil', !allFilled);
Â  Â  continueButton.disabled = !allFilled;
Â  Â  
Â  Â  // â­ LÃ³gica para la clase 'has-new' y el scroll
Â  Â  if (allFilled) {
Â  Â  Â  if (!continueButton.classList.contains('has-new')) {
Â  Â  Â  Â  continueButton.classList.add('has-new');
Â  Â  Â  Â  scrollToButton(continueButton);
Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  continueButton.classList.remove('has-new');
Â  Â  }
Â  }

Â  // --- Resetear botones ---
Â  function resetContinueButtons(form) {
Â  Â  const scope = form || document;
Â  Â  const buttons = scope.querySelectorAll('[continue-target]');
Â  Â  buttons.forEach(button => {
Â  Â  Â  button.classList.add('inutil');
Â  Â  Â  button.disabled = true;
Â  Â  Â  // â­ Al resetear, tambiÃ©n quitar la clase 'has-new'
Â  Â  Â  button.classList.remove('has-new');
Â  Â  });
Â  }
Â  
Â  // --- ConfiguraciÃ³n inicial de listeners para inputs de texto, etc. ---
Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  // Listener para inputs tradicionales
Â  Â  const inputsToValidate = document.querySelectorAll(`input[cf-json-path][continue-trigger]:not([type="hidden"]), textarea[cf-json-path][continue-trigger]`);
Â  Â  
Â  Â  inputsToValidate.forEach(input => {
Â  Â  Â  input.addEventListener('change', (e) => {
Â  Â  Â  Â  const continueButtonId = e.target.getAttribute('continue-trigger');
Â  Â  Â  Â  if (continueButtonId) {
Â  Â  Â  Â  Â  document.dispatchEvent(new CustomEvent('valid-input-change', {
Â  Â  Â  Â  Â  Â  detail: { continueButtonId: continueButtonId }
Â  Â  Â  Â  Â  }));
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  });

Â  Â  // ðŸš€ NUEVO: Listener para validaciÃ³n directa por clic ðŸš€
Â  Â  const directValidationElements = document.querySelectorAll('[direct-validation]');
Â  Â  directValidationElements.forEach(el => {
Â  Â  Â  el.addEventListener('click', (e) => {
Â  Â  Â  Â  const continueButtonId = e.currentTarget.getAttribute('direct-validation');
Â  Â  Â  Â  if (continueButtonId) {
Â  Â  Â  Â  Â  document.dispatchEvent(new CustomEvent('new-direct-validation', {
Â  Â  Â  Â  Â  Â  detail: { continueButtonId: continueButtonId }
Â  Â  Â  Â  Â  }));
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  });
Â  Â  
Â  Â  // Emitir evento de finalizaciÃ³n de configuraciÃ³n
Â  Â  document.dispatchEvent(new Event('input-change-ready'));
Â  });

Â  // --- Escuchar eventos de validaciÃ³n ---
Â  document.addEventListener('valid-change-checkbox', e => {
Â  Â  if (!e.detail || !e.detail.continueButtonId) return;
Â  Â  setTimeout(() => validateContinueButton(e.detail.continueButtonId), VALIDATION_DELAY);
Â  });

Â  document.addEventListener('valid-change-radio', e => {
Â  Â  if (!e.detail || !e.detail.continueButtonId) return;
Â  Â  setTimeout(() => validateContinueButton(e.detail.continueButtonId), VALIDATION_DELAY);
Â  });
Â  
Â  document.addEventListener('valid-change-hidden', e => {
Â  Â  if (!e.detail || !e.detail.continueButtonId) return;
Â  Â  setTimeout(() => validateContinueButton(e.detail.continueButtonId), VALIDATION_DELAY);
Â  });

Â  document.addEventListener('valid-input-change', e => {
Â  Â  if (!e.detail || !e.detail.continueButtonId) return;
Â  Â  setTimeout(() => validateContinueButton(e.detail.continueButtonId), VALIDATION_DELAY);
Â  });

Â  document.addEventListener('new-direct-validation', e => {
Â  Â  if (!e.detail || !e.detail.continueButtonId) return;
Â  Â  setTimeout(() => validateContinueButton(e.detail.continueButtonId), VALIDATION_DELAY);
Â  });

Â  document.addEventListener('reset-continue-buttons', e => {
Â  Â  resetContinueButtons(e.detail);
Â  });
})();
</script>

<!-- reset -->
<script>
(function () {
Â  'use strict';

Â  /* ---------- Utils ---------- */
Â  function safeJSONParse(str, fallback = null) {
Â  Â  try { return JSON.parse(str); } catch (e) { return fallback; }
Â  }

Â  function getInitialHiddenValue(inputType) {
Â  Â  return inputType === 'checkbox' ? '[]' : '{}';
Â  }

Â  /* ---------- Clean deep components ---------- */
Â  function cleanChildComponents(container) {
Â  Â  if (!container || !(container instanceof Element)) return;

Â  Â  // 1. Limpieza de elementos del Color Picker
Â  Â  container.querySelectorAll('a[color-element-template]').forEach(el => {
Â  Â  Â  console.debug('Reset: Simulating click on color picker element:', el);
Â  Â  Â  el.click();
Â  Â  });
Â  Â  const selectColorBtn = container.querySelector('[internal-input-select-color]');
Â  Â  if (selectColorBtn) {
Â  Â  Â  selectColorBtn.style.borderColor = '';
Â  Â  Â  selectColorBtn.style.color = '';
Â  Â  Â  selectColorBtn.classList.remove('previewed');
Â  Â  }

Â  Â  // 2. Limpieza de elementos de Uploader de Uploadcare
Â  Â  container.querySelectorAll('uc-file-item .uc-remove-btn').forEach(button => {
Â  Â  Â  console.debug('Reset: Simulating click on Uploadcare remove button:', button);
Â  Â  Â  button.click();
Â  Â  });

Â  Â  // 3. Limpieza de campos contenteditable
Â  Â  container.querySelectorAll('[contenteditable="true"]').forEach(el => {
Â  Â  Â  console.debug('Reset: Cleaning contenteditable element:', el);
Â  Â  Â  el.innerHTML = '';
Â  Â  });

Â  Â  // 4. Limpieza de inputs nativos y hidden
Â  Â  container.querySelectorAll('input, textarea, select').forEach(i => {
Â  Â  Â  try {
Â  Â  Â  Â  if (i instanceof HTMLInputElement && (i.type === 'checkbox' || i.type === 'radio')) {
Â  Â  Â  Â  Â  i.checked = false;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  i.value = '';
Â  Â  Â  Â  }
Â  Â  Â  Â  if (i.selectedIndex !== undefined) try { i.selectedIndex = -1; } catch (e) {}
Â  Â  Â  } catch (e) {}
Â  Â  });

Â  Â  container.querySelectorAll('[component-id] input[type="hidden"][cf-json-path]').forEach(h => {
Â  Â  Â  try {
Â  Â  Â  Â  const inputType = h.closest('[component-id]').getAttribute('input-type');
Â  Â  Â  Â  h.value = getInitialHiddenValue(inputType);
Â  Â  Â  } catch (e) {}
Â  Â  });
Â  Â  
Â  Â  // 5. Limpieza general de clases de selecciÃ³n
Â  Â  const buttonComponents = container.querySelectorAll('[component-id][input-type="checkbox"], [component-id][input-type="radio"]');
Â  Â  buttonComponents.forEach(comp => {
Â  Â  Â  const fieldClass = comp.getAttribute('f-class'); 
Â  Â  Â  const labelClass = comp.getAttribute('l-class');
Â  Â  Â  
Â  Â  Â  if (fieldClass) { 
Â  Â  Â  Â  comp.querySelectorAll(`.${fieldClass}`).forEach(el => el.classList.remove(fieldClass));
Â  Â  Â  }
Â  Â  Â  if (labelClass) {
Â  Â  Â  Â  comp.querySelectorAll(`.${labelClass}`).forEach(el => el.classList.remove(labelClass));
Â  Â  Â  }
Â  Â  });
Â  }

Â  /* ---------- Reset whole form and dependencies ---------- */
Â  function resetForm(formEl) {
Â  Â  document.dispatchEvent(new CustomEvent('cf-loader-on'));
Â  Â  
Â  Â  // Limpieza completa de todos los campos y componentes dentro del formulario
Â  Â  cleanChildComponents(formEl);

Â  Â  // â­ NUEVO: Resetear el estado `active` en todos los componentes
Â  Â  const allActiveElements = formEl.querySelectorAll('[active="true"]');
Â  Â  allActiveElements.forEach(el => {
Â  Â  Â  el.setAttribute('active', 'false');
Â  Â  });

Â  Â  // Oculta todos los elementos con display-depend
Â  Â  formEl.querySelectorAll('[display-depend]').forEach(node => {
Â  Â  Â  node.style.display = 'none';
Â  Â  });

Â  Â  // Elimina data-required de todos los inputs, excepto los marcados con always-required
Â  Â  const allInputs = formEl.querySelectorAll('input, textarea, select');
Â  Â  allInputs.forEach(h => {
Â  Â  Â  // â­ MODIFICACIÃ“N CLAVE: usar hasAttribute() en lugar de getAttribute()
Â  Â  Â  const alwaysReq = h.hasAttribute('always-required');
Â  Â  Â  if (!alwaysReq) {
Â  Â  Â  Â  h.removeAttribute('data-required');
Â  Â  Â  }
Â  Â  });

Â  Â  // Reinicia el estado de los componentes
Â  Â  const componentsToReset = formEl.querySelectorAll('[component-id]');
Â  Â  componentsToReset.forEach(compEl => {
Â  Â  Â  const inputType = compEl.getAttribute('input-type') || 'checkbox';
Â  Â  Â  const jsonPath = compEl.getAttribute('json-path') || '';
Â  Â  Â  const hiddenInput = compEl.querySelector(`input[cf-json-path="${jsonPath}"]`) || compEl.querySelector('input[type="hidden"][cf-json-path]');
Â  Â  Â  
Â  Â  Â  const detail = {
Â  Â  Â  Â  componentId: compEl.getAttribute('component-id'),
Â  Â  Â  Â  jsonPath: hiddenInput ? hiddenInput.getAttribute('cf-json-path') : null,
Â  Â  Â  Â  type: inputType,
Â  Â  Â  Â  value: null,
Â  Â  Â  Â  label: '',
Â  Â  Â  Â  id: null,
Â  Â  Â  Â  isChecked: false,
Â  Â  Â  Â  currentValue: null
Â  Â  Â  };

Â  Â  Â  document.dispatchEvent(new CustomEvent('option-change', { detail }));
Â  Â  Â  if (inputType === 'checkbox') document.dispatchEvent(new CustomEvent('valid-change-checkbox', { detail }));
Â  Â  Â  else if (inputType === 'radio') document.dispatchEvent(new CustomEvent('valid-change-radio', { detail }));
Â  Â  });

Â  Â  setTimeout(() => {
Â  Â  Â  document.dispatchEvent(new CustomEvent('cf-loader-off'));
Â  Â  }, 120);
Â  }

Â  /* ---------- Instalar listeners ---------- */
Â  function install() {
Â  Â  const reloadEls = document.querySelectorAll('[cf-reload-form]');
Â  Â  reloadEls.forEach(el => {
Â  Â  Â  el.addEventListener('click', function (evt) {
Â  Â  Â  Â  try { evt.preventDefault(); } catch (e) {}
Â  Â  Â  Â  const form = el.closest('[cf-form-submit]') || null;
Â  Â  Â  Â  document.dispatchEvent(new CustomEvent('reset-continue-buttons', { detail: form }));
Â  Â  Â  Â  if (form) {
Â  Â  Â  Â  Â  resetForm(form);
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  });
Â  }

Â  if (document.readyState === 'loading') {
Â  Â  document.addEventListener('DOMContentLoaded', install);
Â  } else {
Â  Â  install();
Â  }
})();
</script>