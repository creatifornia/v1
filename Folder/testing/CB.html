<!-- ü¶ß BLD-7 ü¶ß -->
<script>
(function(){
  'use strict';

  /* ---------- Utils ---------- */
  function safeJSONParse(str, fallback = null) {
    try { return JSON.parse(str); } catch { return fallback; }
  }
  function getNested(obj, path) {
    if (!obj || !path) return undefined;
    return path.split('.').reduce((acc, p) => (acc && acc[p] !== undefined) ? acc[p] : undefined, obj);
  }
  function showErrorModal(message) {
    if (typeof showToast === 'function') showToast(message, 'error');
    else if (typeof alert === 'function') alert(message);
    else console.error(message);
  }

  /* ---------- Estado ---------- */
  const COMPONENTS = new Map();

  /* ---------- Construcci√≥n de todos los componentes ---------- */
  function buildAllComponents() {
    const components = document.querySelectorAll('[component-id]');
    components.forEach(component => {
      try { buildComponent(component); }
      catch (err) { console.error('BuildOptions: Error building component', component.getAttribute('component-id'), err); }
    });

    // Evento de finalizaci√≥n para que otros scripts instalen listeners
    document.dispatchEvent(new Event('options-builder-ready'));
  }

  function buildComponent(component) {
    const componentId = component.getAttribute('component-id');
    const storageKey = component.getAttribute('storage-key') || null;
    const storagePath = component.getAttribute('storage-path') || '';
    const jsonPath = component.getAttribute('json-path') || '';
    const dependencies = String(component.getAttribute('dependencies') || '').toLowerCase() === 'true';
    const valueKey = component.getAttribute('value-key') || 'value';
    const labelKey = component.getAttribute('label-key') || 'label';
    const tagKey = component.getAttribute('tag-key') || 'tag';
    const idKey = component.getAttribute('id-key') || 'id';
    const clickKey = component.getAttribute('click-key') || null;
    const fClass = component.getAttribute('f-class') || '';
    const lClass = component.getAttribute('l-class') || '';
    const continueButtonId = component.getAttribute('continue-button-id') || null;
    const checkboxLimit = component.getAttribute('checkbox-limit') ? parseInt(component.getAttribute('checkbox-limit')) : null;
    const inputType = (component.getAttribute('input-type') || 'checkbox').toLowerCase();
    const groupComponentId = component.getAttribute('group-component-id') || componentId;
    const alwaysRequired = String(component.getAttribute('always-required')).trim().toLowerCase() === 'true';
    const requiredDepend = component.getAttribute('required-depend') || null;
    const displayDepend = component.getAttribute('display-depend') || null;
    const MATCH = component.getAttribute('match') || null;



    // Validaciones m√≠nimas
    if (!componentId || !jsonPath) {
      console.error(`BuildOptions: component "${componentId}": faltan atributos m√≠nimos (component-id, json-path).`);
      return;
    }

    const groupEl = component.querySelector('[role="group"]');
    if (!groupEl) {
      console.error(`BuildOptions: component "${componentId}": falta elemento con role="group".`);
      return;
    }

    const fieldTemplate = component.querySelector('[c-field]');
    if (!fieldTemplate) {
      console.error(`BuildOptions: component "${componentId}": falta plantilla [c-field].`);
      return;
    }

    // Leer options desde localStorage (si existe storageKey), con fallback razonable
    let optionsList = null;
    if (storageKey) {
      const raw = localStorage.getItem(storageKey);
      const storedObj = safeJSONParse(raw, null);
      if (storedObj) {
        if (storagePath) optionsList = getNested(storedObj, `${storagePath}.options`);
        else if (Array.isArray(storedObj)) optionsList = storedObj;
        else if (Array.isArray(storedObj.options)) optionsList = storedObj.options;
      } else {
        console.warn(`BuildOptions: component "${componentId}": no hay datos v√°lidos en localStorage["${storageKey}"].`);
      }
    }

    // Si no hay options desde localStorage, intentar leer opciones est√°ticas (clonando plantilla)
    if (!Array.isArray(optionsList) || optionsList.length === 0) {
      // Option: no abortamos, permitimos componentes sin options (por si son controlados externamente)
      optionsList = [];
    }

    // Hidden input principal (cf-json-path)
    let hidden = component.querySelector(`input[type="hidden"][cf-json-path="${jsonPath}"]`);
    if (!hidden) {
      hidden = document.createElement('input');
      hidden.type = 'hidden';
      hidden.setAttribute('cf-json-path', jsonPath);
      hidden.name = jsonPath;
      component.appendChild(hidden);
    }

  if (alwaysRequired) {
  hidden.setAttribute('data-required', '');
  hidden.setAttribute('always-required', ''); // para que siga visible en el DOM si quieres
}


    // Si existe continueButtonId, lo exponemos como continue-trigger en el hidden
    if (continueButtonId) {
      hidden.setAttribute('continue-trigger', continueButtonId);
    }

    // Inicial value del hidden seg√∫n tipo
    if (inputType === 'checkbox') hidden.value = hidden.value || '[]';
    else hidden.value = hidden.value || '{}';

    // Vaciar el grupo y (si hay optionsList) clonar template por cada opci√≥n
    while (groupEl.firstChild) groupEl.removeChild(groupEl.firstChild);

    if (optionsList.length) {
      optionsList.forEach(item => {
        const clone = fieldTemplate.cloneNode(true);
        const tagEl = clone.querySelector('[c-tag]');
        const labelEl = clone.querySelector('[c-label]');
        const nativeInput = clone.querySelector('[native-button], input[type="checkbox"], input[type="radio"], input');

        const labelText = String(item[labelKey] ?? '');
        const tagText = String(item[tagKey] ?? '').trim();
        const valText = String(item[valueKey] ?? '');
        const idVal = idKey ? (item[idKey] !== undefined ? String(item[idKey]) : null) : null;
        const clickVal = clickKey ? (item[clickKey] !== undefined ? String(item[clickKey]) : null) : null;

        if (labelEl) labelEl.textContent = labelText;
        if (tagEl) {
          if (tagText) { tagEl.textContent = tagText; tagEl.style.display = ''; }
          else { tagEl.textContent = ''; tagEl.style.display = 'none'; }
        }

        if (nativeInput) {
          nativeInput.type = inputType;
          nativeInput.setAttribute('data-opt-value', valText);
          nativeInput.setAttribute('data-opt-label', labelText);
          if (idVal) nativeInput.setAttribute('data-opt-id', idVal);
          if (tagText) nativeInput.setAttribute('data-opt-tag', tagText);
          if (clickVal) nativeInput.setAttribute('data-opt-click', clickVal);
          if (inputType === 'radio') nativeInput.name = groupComponentId;
        } else {
          console.warn(`BuildOptions: component "${componentId}": clone c-field no contiene native-button ni input detectable.`);
        }

        if (clickVal) clone.setAttribute('cl', clickVal);
        groupEl.appendChild(clone);
      });
    } else {
      // No hay options en localStorage: intentamos usar la plantilla tal cual (si contiene inputs ya en markup)
      // No hacemos nada adicional; se asume que markup ya contiene inputs si son est√°ticos.
    }

    // Registrar listener delegado de cambios solo una vez por grupo
    if (!groupEl._hasDelegate) {
      groupEl.addEventListener('change', (evt) => onGroupChange(evt, componentId));
      groupEl._hasDelegate = true;
    }

    // Guardar estado m√≠nimo en map
    COMPONENTS.set(componentId, {
      componentId,
      componentEl: component,
      storageKey,
      storagePath,
      jsonPath,
      dependencies, // <-- nuevo flag
      valueKey,
      labelKey,
      tagKey,
      idKey,
      clickKey,
      fClass,
      lClass,
      continueButtonId,
      checkboxLimit,
      inputType,
      groupEl,
      fieldTemplate,
      hiddenEl: hidden,
      alwaysRequired,
      displayDepend,
      requiredDepend,
      MATCH,
      currentValue: inputType === 'checkbox' ? [] : {}
      
    });

    // Sincronizar UI desde el hidden (si ya hay valor)
    syncUIFromHidden(componentId);
  }

  /* ---------- Sincronizar UI inicial desde hidden ---------- */
  function syncUIFromHidden(componentId) {
    const state = COMPONENTS.get(componentId);
    if (!state) return;
    const { hiddenEl, inputType, groupEl, fClass, lClass } = state;
    const raw = hiddenEl.value;
    if (raw === undefined || raw === null) return;
    const parsed = safeJSONParse(raw, null);

    // limpiar marcas previas
    groupEl.querySelectorAll('[c-field]').forEach(fe => {
      if (fClass) fe.classList.remove(fClass);
      const lab = fe.querySelector('[c-label]');
      if (lab && lClass) lab.classList.remove(lClass);
      const inp = fe.querySelector('[native-button], input');
      if (inp) inp.checked = false;
    });

    if (inputType === 'checkbox' && Array.isArray(parsed)) {
      parsed.forEach(item => {
        groupEl.querySelectorAll('[native-button], input').forEach(inp => {
          if (String(inp.getAttribute('data-opt-value')) === String(item.value)) {
            inp.checked = true;
            const fe = inp.closest('[c-field]');
            fe && fClass && fe.classList.add(fClass);
            const lab = fe && fe.querySelector('[c-label]');
            lab && lClass && lab.classList.add(lClass);
          }
        });
      });
      state.currentValue = parsed.slice();
    } else if (inputType === 'radio' && parsed && typeof parsed === 'object' && Object.keys(parsed).length) {
      groupEl.querySelectorAll('[native-button], input').forEach(inp => {
        if (String(inp.getAttribute('data-opt-value')) === String(parsed.value)) {
          inp.checked = true;
          const fe = inp.closest('[c-field]');
          fe && fClass && fe.classList.add(fClass);
          const lab = fe && fe.querySelector('[c-label]');
          lab && lClass && lab.classList.add(lClass);
        }
      });
      state.currentValue = parsed;
    } else {
      state.currentValue = inputType === 'checkbox' ? [] : {};
    }
  }

  /* ---------- Cambio delegado en role=group ---------- */
  function onGroupChange(evt, componentId) {
    const input = evt.target;
    if (!input || !(input instanceof HTMLInputElement)) return;

    const state = COMPONENTS.get(componentId);
    if (!state) return;

    const { inputType, hiddenEl, checkboxLimit, fClass, lClass, groupEl, dependencies } = state;
    const value = input.getAttribute('data-opt-value');
    const label = input.getAttribute('data-opt-label') || '';
    const id = input.getAttribute('data-opt-id') || null;
    const isChecked = input.checked;

    if (inputType === 'checkbox') {
      let current = safeJSONParse(hiddenEl.value, []);
      current = Array.isArray(current) ? current : [];

      const exists = current.some(it => String(it.value) === String(value));
      if (isChecked && !exists) {
        if (checkboxLimit && current.length >= checkboxLimit) {
          showErrorModal(`Selecciona m√°ximo ${checkboxLimit} opciones.`);
          input.checked = false;
          return;
        }
        const entry = { value, label };
        if (id) entry.id = id;
        current.push(entry);
      } else if (!isChecked && exists) {
        current = current.filter(it => String(it.value) !== String(value));
      }

      const fieldEl = input.closest('[c-field]');
      fieldEl && fClass && fieldEl.classList.toggle(fClass, isChecked);
      const lab = fieldEl && fieldEl.querySelector('[c-label]');
      lab && lClass && lab.classList.toggle(lClass, isChecked);

      hiddenEl.value = JSON.stringify(current);
      state.currentValue = current.slice();

      emitOptionEvents('checkbox', state, input, { value, label, id, isChecked, currentValue: current });

    } else if (inputType === 'radio') {
      const entry = { value, label };
      if (id) entry.id = id;

      groupEl.querySelectorAll('[c-field]').forEach(fe => {
        fClass && fe.classList.remove(fClass);
        const lab = fe.querySelector('[c-label]');
        lab && lClass && lab.classList.remove(lClass);
      });

      const fieldEl = input.closest('[c-field]');
      fieldEl && fClass && fieldEl.classList.add(fClass);
      const lab = fieldEl && fieldEl.querySelector('[c-label]');
      lab && lClass && lab.classList.add(lClass);

      hiddenEl.value = JSON.stringify(entry);
      state.currentValue = Object.assign({}, entry);

      emitOptionEvents('radio', state, input, { value, label, id, isChecked: true, currentValue: state.currentValue });
    }

    // NOTA: el builder solo actualiza valor y emite eventos.
    // La gesti√≥n de display/required queda en los handlers externos que escuchan valid-change-*
  }

/* ---------- Emitir eventos (compatibles con handlers) ---------- */
function emitOptionEvents(type, state, input, payload) {
  const detail = {
    componentId: state.componentId,
    jsonPath: state.jsonPath,
    type,
    value: payload.value,
    label: payload.label,
    id: payload.id,
    isChecked: payload.isChecked,
    currentValue: payload.currentValue,
    alwaysRequired: state.alwaysRequired,
    dependencies: state.dependencies,
    requiredDepend: state.requiredDepend,
    displayDepend: state.displayDepend,
    continueButtonId: state.continueButtonId,
    match: state.MATCH
  };

  // üîç Log visual del evento
  console.group(`üì§ Emitiendo evento de opci√≥n (${type})`);
  console.table(detail);
  console.groupEnd();

  document.dispatchEvent(new CustomEvent('option-change', { detail }));
  if (type === 'checkbox') {
    document.dispatchEvent(new CustomEvent('valid-change-checkbox', { detail }));
  } else if (type === 'radio') {
    document.dispatchEvent(new CustomEvent('valid-change-radio', { detail }));
  }
}


  /* ---------- Inicializaci√≥n: escuchar data-ready ---------- */
  document.addEventListener('data-ready', buildAllComponents);

  // Exponer para debugging
  window.__OptionsBuilder = { COMPONENTS };

})();
</script>


<!-- üü¶ CBX-2 (Handler corregido: actualiza hidden + dependencias) üü¶ -->
<script>
(function(){
  'use strict';

  // Utiles
  function safeJSONParse(str, fallback = null) {
    try { return JSON.parse(str); } catch { return fallback; }
  }

  function clearHiddenAndUIForAncestor(hiddenEl) {
    const ancestorComp = hiddenEl.closest('[component-id]');
    if (!ancestorComp) {
      try {
        const parsed = JSON.parse(hiddenEl.value || '');
        hiddenEl.value = Array.isArray(parsed) ? '[]' : '{}';
      } catch {
        hiddenEl.value = '[]';
      }
      return;
    }

    const inputType = (ancestorComp.getAttribute('input-type') || 'checkbox').toLowerCase();
    const fClass = ancestorComp.getAttribute('f-class') || '';
    const lClass = ancestorComp.getAttribute('l-class') || '';
    const groupEl = ancestorComp.querySelector('[role="group"]');

    hiddenEl.value = (inputType === 'checkbox') ? '[]' : '{}';

    if (groupEl) {
      groupEl.querySelectorAll('[native-button], input').forEach(i => {
        try { i.checked = false; } catch(e){}
      });
      groupEl.querySelectorAll('[c-field]').forEach(fe => {
        if (fClass) fe.classList.remove(fClass);
        const lab = fe.querySelector('[c-label]');
        if (lab && lClass) lab.classList.remove(lClass);
      });
    }
  }

  // Checkbox handler: escuchar evento emitido por el builder
  document.addEventListener('valid-change-checkbox', (e) => {
    try {
      const detail = e.detail || {};
      const componentId = detail.componentId;
      const dependencies = !!detail.dependencies; // true/false
      const currentValue = Array.isArray(detail.currentValue) ? detail.currentValue : [];
      const currentValues = currentValue.map(it => String(it.value));
      const jsonPath = detail.jsonPath || null;
      const continueButtonId = detail.continueButtonId || null;

      console.debug('CBX-2: received valid-change-checkbox', { componentId, jsonPath, currentValue, continueButtonId, dependencies });

      // Si este componente no maneja dependencias, salimos (pero a√∫n actualizamos hidden por seguridad)
      // Nota: si NO quieres actualizar hidden cuando dependencies === false, cambia esta l√≠nea.
      if (!componentId) return;

      // Buscar componente (scope)
      const component = document.querySelector(`[component-id="${componentId}"]`);
      if (!component) {
        console.debug('CBX-2: componente no encontrado', componentId);
        return;
      }
      const scope = component.closest('[cf-form-submit]') || document;

      // ----------------------------
      //  ACTUALIZAR HIDDEN DEL COMPONENTE (clave)
      // ----------------------------
      if (jsonPath) {
        let compHidden = component.querySelector(`input[cf-json-path="${jsonPath}"]`);
        if (!compHidden) compHidden = component.querySelector(`input[type="hidden"][cf-json-path]`);
        if (compHidden) {
          try {
            compHidden.value = JSON.stringify(currentValue);
            // dispatch change so continue handler (or other listeners) pick it up
            compHidden.dispatchEvent(new Event('change', { bubbles: true }));
            console.debug('CBX-2: updated component hidden', { compHidden, newValue: compHidden.value });
          } catch (err) {
            console.error('CBX-2: error setting hidden value', err);
          }
        } else {
          console.debug('CBX-2: hidden input no encontrado en el componente para jsonPath', jsonPath);
        }
      }

      // Si no maneja dependencias, terminamos aqu√≠
      if (!dependencies) {
        return;
      }

      // DISPLAY: mostrar nodos cuyo match est√© en currentValues; ocultar el resto
      const displayNodes = scope.querySelectorAll(`[display-depend="${componentId}"]`);
      displayNodes.forEach(node => {
        const match = node.getAttribute('match');
        const shouldShow = match ? currentValues.includes(String(match).trim()) : (currentValues.length > 0);
        node.style.display = shouldShow ? '' : 'none';
      });

      // REQUIRED: para cada nodo required-depend
      const requiredNodes = scope.querySelectorAll(`[required-depend="${componentId}"]`);
      requiredNodes.forEach(node => {
        const match = node.getAttribute('match');

        // Buscar elementos con cf-json-path y quedarnos s√≥lo con inputs/select/textarea
        const candidates = Array.from(node.querySelectorAll('[cf-json-path]'))
          .filter(el => el && el.matches && el.matches('input,textarea,select'));

        // Decidir si establecer required:
        // - Si hay match: true s√≥lo si match est√° en currentValues
        // - Si no hay match: true si hay al menos una selecci√≥n (currentValues.length > 0)
        const shouldRequire = match
          ? currentValues.includes(String(match).trim())
          : (currentValues.length > 0);

        if (shouldRequire) {
          candidates.forEach(h => {
            h.setAttribute('data-required', '');
            // Notificar a otros listeners (continue handler)
            try { h.dispatchEvent(new Event('change', { bubbles: true })); } catch(e){}
            console.debug('CBX-2: set data-required on', h);
          });
        } else {
          candidates.forEach(h => {
            // Si el candidate tiene atributo always-required y es true, no remover
            const alwaysReqAttr = h.getAttribute('always-required');
            const alwaysReq = String(alwaysReqAttr).trim().toLowerCase() === 'true';
            if (alwaysReq) {
              console.debug('CBX-2: candidate has always-required, skipping removal for', h);
              return;
            }

            h.removeAttribute('data-required');
            // limpiar el hidden/UI asociado
            try { clearHiddenAndUIForAncestor(h); } catch(e){}
            try { h.dispatchEvent(new Event('change', { bubbles: true })); } catch(e){}
            console.debug('CBX-2: removed data-required and cleared', h);
          });
        }
      });

      // Si el evento trae continueButtonId, podemos forzar validaci√≥n (opcional)
      if (continueButtonId) {
        try {
          // dispatch a small custom event so continue handler can catch it if needed
          document.dispatchEvent(new CustomEvent('trigger-validate-continue', { detail: { continueButtonId } }));
        } catch(e){}
      }

    } catch (err) {
      console.error('CBX-2 handler error', err);
    }
  });

})();
</script>


<!-- üü¶ RDO-1 üü¶ -->
<script>
(function(){
  'use strict';

  function safeJSONParse(str, fallback = null) {
    try { return JSON.parse(str); } catch { return fallback; }
  }

  function clearHiddenAndUIForAncestor(hiddenEl) {
    const ancestorComp = hiddenEl.closest('[component-id]');
    if (!ancestorComp) {
      try {
        const parsed = JSON.parse(hiddenEl.value || '');
        hiddenEl.value = Array.isArray(parsed) ? '[]' : '{}';
      } catch {
        hiddenEl.value = '[]';
      }
      return;
    }

    const inputType = (ancestorComp.getAttribute('input-type') || 'checkbox').toLowerCase();
    const fClass = ancestorComp.getAttribute('f-class') || '';
    const lClass = ancestorComp.getAttribute('l-class') || '';
    const groupEl = ancestorComp.querySelector('[role="group"]');

    hiddenEl.value = (inputType === 'checkbox') ? '[]' : '{}';

    if (groupEl) {
      groupEl.querySelectorAll('[native-button], input').forEach(i => {
        try { i.checked = false; } catch(e){}
      });
      groupEl.querySelectorAll('[c-field]').forEach(fe => {
        if (fClass) fe.classList.remove(fClass);
        const lab = fe.querySelector('[c-label]');
        if (lab && lClass) lab.classList.remove(lClass);
      });
    }
  }

  // Radio handler: escucha evento emitido por el builder
  document.addEventListener('valid-change-radio', (e) => {
    try {
      const detail = e.detail || {};
      const componentId = detail.componentId;
      const dependencies = !!detail.dependencies;
      const selectedValue = (detail.value !== undefined && detail.value !== null) ? String(detail.value).trim() : null;

      // Si no hay dependencias, no actuamos
      if (!dependencies) return;

      // Localizar componente y scope (preferir cf-form-submit)
      const component = document.querySelector(`[component-id="${componentId}"]`);
      if (!component) return;
      const scope = component.closest('[cf-form-submit]') || document;

      // 1) DISPLAY: mostrar/ocultar nodes con display-depend="{componentId}"
      const displayNodes = scope.querySelectorAll(`[display-depend="${componentId}"]`);
      displayNodes.forEach(node => {
        const match = node.getAttribute('match');
        const shouldShow = match ? (selectedValue !== null && String(match).trim() === selectedValue) : (selectedValue !== null);
        node.style.display = shouldShow ? '' : 'none';
      });

      // 2) REQUIRED: manejar required-depend
      const requiredNodes = scope.querySelectorAll(`[required-depend="${componentId}"]`);
      requiredNodes.forEach(node => {
        const match = node.getAttribute('match');

        // buscar elementos relevantes que expongan cf-json-path
        const candidates = Array.from(node.querySelectorAll('[cf-json-path]'))
          .filter(el => el && el.matches && el.matches('input,textarea,select'));

        // decidir si se debe marcar required:
        // - si hay match: true solo cuando match == selectedValue
        // - si no hay match: true cuando hay alguna selecci√≥n (selectedValue !== null)
        const shouldRequire = match
          ? (selectedValue !== null && String(match).trim() === selectedValue)
          : (selectedValue !== null);

        if (shouldRequire) {
          candidates.forEach(h => {
            h.setAttribute('data-required', '');
            try { h.dispatchEvent(new Event('change', { bubbles: true })); } catch (err) {}
          });
        } else {
          candidates.forEach(h => {
            h.removeAttribute('data-required');
            try { clearHiddenAndUIForAncestor(h); } catch (err) {}
            try { h.dispatchEvent(new Event('change', { bubbles: true })); } catch (err) {}
          });
        }
      });

    } catch (err) {
      console.error('Radio-v3 handler error', err);
    }
  });

})();
</script>


<!-- üê¨ Reset-v1 üê¨ -->
<script>
(function () {
  'use strict';

  /* ---------- Utils ---------- */
  function safeJSONParse(str, fallback = null) {
    try { return JSON.parse(str); } catch (e) { return fallback; }
  }
  function getInitialHiddenValue(inputType) {
    return inputType === 'checkbox' ? '[]' : '{}';
  }

  /* ---------- Hide display-depend elements for components that declare has-deps="true" ---------- */
  function hideDisplayDependents(formEl) {
    const scope = formEl || document;
    const hiddenElements = [];
    // buscamos componentes dentro del scope que tengan has-deps="true"
    const compsWithDeps = scope.querySelectorAll('[component-id][has-deps="true"]');
    const seen = new Set();

    compsWithDeps.forEach(comp => {
      const compId = comp.getAttribute('component-id');
      if (!compId || seen.has(compId)) return;
      seen.add(compId);

      // buscamos los elementos que dependen visualmente de este component-id
      const selector = `[display-depend="${compId}"]`;
      const targets = (formEl ? formEl.querySelectorAll(selector) : document.querySelectorAll(selector));
      targets.forEach(t => {
        // ocultamos por inline-style (no tocamos clases)
        t.style.display = 'none';
        hiddenElements.push(t);
      });
    });

    return hiddenElements;
  }

  /* ---------- Core reset for a single component (v2-aware) ---------- */
  function resetComponentState(componentEl) {
    const map = window.__OptionsBuilder && window.__OptionsBuilder.COMPONENTS ? window.__OptionsBuilder.COMPONENTS : null;
    const componentId = componentEl.getAttribute('component-id');
    const state = map && map.get(componentId) ? map.get(componentId) : null;

    const inputType = state ? state.inputType : (componentEl.getAttribute('input-type') || 'checkbox').toLowerCase();
    const parentAttr = state ? state.parent : (componentEl.getAttribute('parent') || '');
    const fClass = state ? state.fClass : (componentEl.getAttribute('f-class') || '');
    const lClass = state ? state.lClass : (componentEl.getAttribute('l-class') || '');
    const groupEl = state ? state.groupEl : componentEl.querySelector('[role="group"]');

    let hidden = state && state.hiddenEl ? state.hiddenEl : componentEl.querySelector('input[type="hidden"][cf-json-path]');
    if (!hidden) {
      hidden = document.createElement('input');
      hidden.type = 'hidden';
      const jp = componentEl.getAttribute('json-path') || ('component.' + (componentId || Math.random().toString(36).slice(2)));
      hidden.setAttribute('cf-json-path', jp);
      componentEl.appendChild(hidden);
    }

    const initialVal = getInitialHiddenValue(inputType);

    if (!parentAttr) {
      // Parent: restaurar estado original: data-required presente y hidden en valor inicial
      hidden.setAttribute('data-required', '');
      hidden.value = initialVal;

      // limpiar UI
      if (groupEl) {
        groupEl.querySelectorAll('[native-button], input').forEach(inp => {
          if (inp.type === 'checkbox' || inp.type === 'radio') inp.checked = false;
          else inp.value = '';
        });
        groupEl.querySelectorAll('[c-field]').forEach(fe => {
          if (fClass) fe.classList.remove(fClass);
          const lab = fe.querySelector('[c-label]');
          if (lab && lClass) lab.classList.remove(lClass);
        });
      }
    } else {
      // Child: quitar data-required, ocultar display-dep (se har√° globalmente despu√©s) y resetear
      hidden.removeAttribute('data-required');
      hidden.value = initialVal;

      componentEl.querySelectorAll('[data-required]').forEach(inp => inp.removeAttribute('data-required'));

      componentEl.querySelectorAll('input').forEach(inp => {
        if (inp.type === 'radio' || inp.type === 'checkbox') inp.checked = false;
        else inp.value = '';
      });

      componentEl.querySelectorAll('[c-field]').forEach(fe => {
        if (fClass) fe.classList.remove(fClass);
        const lab = fe.querySelector('[c-label]');
        if (lab && lClass) lab.classList.remove(lClass);
      });

      // Nota: los display-depend reales se ocultan globalmente tras resetForm (hideDisplayDependents)
    }

    // Emitir eventos para que el sistema reeval√∫e dependencias
    let parsedValue = safeJSONParse(hidden.value, null);
    parsedValue = (inputType === 'checkbox') ? (Array.isArray(parsedValue) ? parsedValue : []) : ((parsedValue && typeof parsedValue === 'object') ? parsedValue : {});

    const detail = {
      componentId: componentId,
      jsonPath: hidden.getAttribute('cf-json-path'),
      type: inputType,
      value: null,
      label: '',
      id: null,
      isChecked: false,
      currentValue: parsedValue
    };

    document.dispatchEvent(new CustomEvent('option-change', { detail }));
    if (inputType === 'checkbox') document.dispatchEvent(new CustomEvent('valid-change-checkbox', { detail }));
    else if (inputType === 'radio') document.dispatchEvent(new CustomEvent('valid-change-radio', { detail }));

    return;
  }

  /* ---------- Reset whole form ---------- */
  function resetForm(formEl) {
    // show loader
    document.dispatchEvent(new CustomEvent('cf-loader-on'));

    const map = window.__OptionsBuilder && window.__OptionsBuilder.COMPONENTS ? window.__OptionsBuilder.COMPONENTS : null;

    // Reseteamos componentes dentro del form (o todos si formEl === null)
    if (map) {
      for (const [compId, state] of map.entries()) {
        const compEl = state && state.componentEl;
        if (!compEl) continue;
        if (!formEl || compEl.closest('[cf-form-submit]') === formEl) resetComponentState(compEl);
      }
    } else {
      const all = formEl ? formEl.querySelectorAll('[component-id]') : document.querySelectorAll('[component-id]');
      all.forEach(compEl => resetComponentState(compEl));
    }


    setTimeout(() => {
      hideDisplayDependents(formEl);

      // dar otro micro-tick para que layout/repintado aplique, luego apagar loader
      setTimeout(() => {
        document.dispatchEvent(new CustomEvent('cf-loader-off'));
      }, 60);
    }, 80);
  }

  /* ---------- Instalar listeners en DOMContentLoaded ---------- */
  function install() {
    const reloadEls = document.querySelectorAll('[cf-reload-form]');
    reloadEls.forEach(el => {
      el.addEventListener('click', function (evt) {
        try { evt.preventDefault(); } catch (e) { /* ignore*/ }
        const form = el.closest('[cf-form-submit]') || null;
        //actualizame este esto que te estoy dando para incluirir correcamtente:
        document.dispatchEvent(new CustomEvent('reset-continue-buttons', {
          detail: form
        }));
        resetForm(form);
      });
    });


  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', install);
  } else {
    install();
  }

})();
</script>


<!-- üöÄ CON-1 (Actualizado) üöÄ -->
<script>
(function(){
  'use strict';
  
  // --- M√≥dulo de validaci√≥n ---
  const ValidationModule = {
    isFieldEmpty: function(field) {
      const rawValue = field.value;
      
      if (rawValue === '[]' || rawValue === '{}') return true;
      
      try {
        const parsed = JSON.parse(rawValue);
        if (Array.isArray(parsed) && parsed.length === 0) return true;
        if (typeof parsed === 'object' && Object.keys(parsed).length === 0) return true;
      } catch (e) {
        return !rawValue || rawValue.trim() === '';
      }
      
      return false;
    }
  };

  // --- Validar y actualizar bot√≥n ---
  function validateContinueButton(buttonId) {
    if (!buttonId) return; // ‚õî Ignorar si es null o undefined

    const requiredFields = document.querySelectorAll(
      `[continue-trigger="${buttonId}"][data-required]`
    );
    
    let allFilled = true;
    
    requiredFields.forEach(field => {
      if (ValidationModule.isFieldEmpty(field)) {
        allFilled = false;
      }
    });
    
    const continueButton = document.getElementById(buttonId);
    if (!continueButton) return;
    
    continueButton.classList.toggle('inutil', !allFilled);
    continueButton.disabled = !allFilled;
  }

  // --- Resetear botones ---
  function resetContinueButtons(form) {
    const scope = form || document;
    const buttons = scope.querySelectorAll('[continue-target]');
    buttons.forEach(button => {
      button.classList.add('inutil');
      button.disabled = true;
    });
  }

  // --- Escuchar eventos ---
  document.addEventListener('valid-change-checkbox', e => {
    if (!e.detail || !e.detail.continueButtonId) return;
    validateContinueButton(e.detail.continueButtonId);
  });

  document.addEventListener('valid-change-radio', e => {
    if (!e.detail || !e.detail.continueButtonId) return;
    validateContinueButton(e.detail.continueButtonId);
  });

  document.addEventListener('reset-continue-buttons', e => {
    resetContinueButtons(e.detail);
  });
  
  // Escuchar cambios en campos normales
  document.addEventListener('change', function(e) {
    const field = e.target;
    if (field.hasAttribute('continue-trigger')) {
      handleNormalFieldChange(field);
    }
  });

})();
</script>




<!-- üîπ cf-input simple: crece hasta maxWidth, luego deja de crecer (no multi-line) üîπ -->
<script>
(function(){
  'use strict';

  /* ---------- util: parse px ---------- */
  function parsePx(v){
    if (!v && v !== 0) return null;
    const s = String(v).trim();
    const m = s.match(/^(\d+(?:\.\d+)?)px$/);
    if (m) return Number(m[1]);
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  /* ---------- obtener maxWidth num√©rico (px) para un elemento ---------- */
  function getNumericMaxWidth(el){
    // 1) data-maxwidth (valor en px o n√∫mero)
    const d = el.getAttribute('data-maxwidth');
    const fromAttr = parsePx(d) || (d && !isNaN(Number(d)) ? Number(d) : null);
    if (fromAttr) return fromAttr;

    // 2) inline style maxWidth
    const inline = el.style.maxWidth;
    const fromInline = parsePx(inline);
    if (fromInline) return fromInline;

    // 3) computed maxWidth
    const cs = getComputedStyle(el);
    const computed = cs.maxWidth;
    const fromComputed = parsePx(computed);
    if (fromComputed) return fromComputed;

    // 4) fallback: ancho del contenedor
    const parent = el.parentElement;
    const parentWidth = parent ? parent.clientWidth : window.innerWidth;
    return parentWidth || window.innerWidth;
  }

  /* ---------- medidor de texto (span fuera de flujo) ---------- */
  const measurer = (function(){
    const span = document.createElement('span');
    span.style.position = 'absolute';
    span.style.left = '-9999px';
    span.style.top = '-9999px';
    span.style.visibility = 'hidden';
    span.style.whiteSpace = 'pre'; // respetar espacios
    document.body.appendChild(span);
    return {
      width(text, font){
        span.style.font = font || '';
        span.textContent = text || '';
        return span.getBoundingClientRect().width;
      }
    };
  })();

  function fontFor(node){
    const cs = getComputedStyle(node);
    return `${cs.fontStyle} ${cs.fontVariant} ${cs.fontWeight} ${cs.fontSize}/${cs.lineHeight} ${cs.fontFamily}`;
  }

  /* ---------- l√≥gica por input ---------- */
  function installSimpleAutosize(inputEl){
    if (!inputEl || inputEl.__cf_simple_installed) return;
    inputEl.__cf_simple_installed = true;

    // Solo trabajar con inputs tipo text (si quieres incluir otros types, qu√≠talo)
    if (inputEl.tagName.toLowerCase() !== 'input') return;
    // default padding 5px left/right si no existe inline
    if (!inputEl.style.paddingLeft) inputEl.style.paddingLeft = '5px';
    if (!inputEl.style.paddingRight) inputEl.style.paddingRight = '5px';

    let maxWidth = getNumericMaxWidth(inputEl);
    const parent = inputEl.parentElement;

    function recomputeMax(){
      maxWidth = getNumericMaxWidth(inputEl);
    }

    function updateWidth(){
      // medir texto (priorizar value, sino placeholder)
      const text = inputEl.value || inputEl.placeholder || '';
      const font = fontFor(inputEl);
      const textW = Math.ceil(measurer.width(text, font));
      const paddingTotal = 10; // 5 + 5
      const desired = textW + paddingTotal;
      const containerMax = Math.min(maxWidth, parent ? parent.clientWidth : window.innerWidth);

      // si desired < containerMax -> ajustar width a desired
      // si desired >= containerMax -> fijar width a containerMax (no crecer m√°s)
      const finalWidth = desired < containerMax ? Math.max(30, desired) : containerMax;
      inputEl.style.boxSizing = 'content-box';
      inputEl.style.width = finalWidth + 'px';
      // no tocamos overflow: el input seguir√° comportamiento nativo de scroll interno
    }

    // handler: usar RAF para performance
    let rafId = null;
    function scheduleUpdate(){
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => {
        updateWidth();
        rafId = null;
      });
    }

    // listeners
    inputEl.addEventListener('input', scheduleUpdate);
    inputEl.addEventListener('change', scheduleUpdate);
    inputEl.addEventListener('paste', () => setTimeout(scheduleUpdate, 0));
    // si el contenedor cambia de tama√±o, recomputar max e intentar ajustar
    window.addEventListener('resize', () => {
      recomputeMax();
      scheduleUpdate();
    });

    // inicial
    scheduleUpdate();
  }

  /* ---------- Orquestador: data-ready ---------- */
  document.addEventListener('data-ready', () => {
    try {
      const nodes = Array.from(document.querySelectorAll('[cf-input]'));
      // Filtrar solo inputs (no textareas) por dise√±o simple
      const inputs = nodes.filter(n => n && n.tagName && n.tagName.toLowerCase() === 'input');
      inputs.forEach(i => installSimpleAutosize(i));

      // listo
      setTimeout(() => document.dispatchEvent(new Event('resize-inputs-readyState')), 60);
    } catch (err) {
      console.error('cf-input simple autosize error', err);
      try { document.dispatchEvent(new Event('resize-inputs-readyState')); } catch(e){}
    }
  });
})();
</script>
